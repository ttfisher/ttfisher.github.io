<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="设计模式,">








  <link rel="shortcut icon" type="image/x-icon" href="https://github.com/ttfisher/images/raw/master/00-head.jpg?v=5.1.1">






<meta name="description" content="【引言】干我们这一行的，设计模式始终是绕不过的一座山，正如一句老话说的“出来混迟早要还的”；想来设计模式常见的就有二十多种，若全部揉到一篇来说定然很臃肿，故而分散开来按类别逐一梳理，此为开篇第一章，主要聊聊背景知识和基础理论。">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式扫盲系列（一）：溯源理论基石">
<meta property="og:url" content="https://ttfisher.github.io/post/a48f4308.html">
<meta property="og:site_name" content="Modern Shine">
<meta property="og:description" content="【引言】干我们这一行的，设计模式始终是绕不过的一座山，正如一句老话说的“出来混迟早要还的”；想来设计模式常见的就有二十多种，若全部揉到一篇来说定然很臃肿，故而分散开来按类别逐一梳理，此为开篇第一章，主要聊聊背景知识和基础理论。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/ttfisher/images/raw/master/2018/2018-05-25-01.jpg">
<meta property="og:image" content="https://github.com/ttfisher/images/raw/master/2019/2019-05-23-01.jpg">
<meta property="og:image" content="https://github.com/ttfisher/images/raw/master/2018/2018-08-19-01.jpg">
<meta property="og:image" content="https://github.com/ttfisher/images/raw/master/2018/2018-08-19-02.jpg">
<meta property="og:updated_time" content="2019-06-02T23:17:31.443Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式扫盲系列（一）：溯源理论基石">
<meta name="twitter:description" content="【引言】干我们这一行的，设计模式始终是绕不过的一座山，正如一句老话说的“出来混迟早要还的”；想来设计模式常见的就有二十多种，若全部揉到一篇来说定然很臃肿，故而分散开来按类别逐一梳理，此为开篇第一章，主要聊聊背景知识和基础理论。">
<meta name="twitter:image" content="https://github.com/ttfisher/images/raw/master/2018/2018-05-25-01.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":15,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '0TSUY3VASO',
      apiKey: '304d5df2e2f136515f540ea8c77beb60',
      indexName: 'ttfisher',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ttfisher.github.io/post/a48f4308.html">





  <title>设计模式扫盲系列（一）：溯源理论基石 | Modern Shine</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Modern Shine</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">莫等闲，白了少年头...</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
			<!--增加的代码 start-->
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ttfisher.github.io/post/a48f4308.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lin.C">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://pm4hdun71.bkt.clouddn.com/img/00-head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Modern Shine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">设计模式扫盲系列（一）：溯源理论基石</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T15:26:13+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术结构升级之设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">技术结构升级之设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>【引言】干我们这一行的，设计模式始终是绕不过的一座山，正如一句老话说的“出来混迟早要还的”；想来设计模式常见的就有二十多种，若全部揉到一篇来说定然很臃肿，故而分散开来按类别逐一梳理，此为开篇第一章，主要聊聊背景知识和基础理论。</p>
<div align="center"><img src="https://github.com/ttfisher/images/raw/master/2018/2018-05-25-01.jpg" width="55%"></div>

<a id="more"></a>
<h1 id="设计模式到底是什么？"><a href="#设计模式到底是什么？" class="headerlink" title="设计模式到底是什么？"></a>设计模式到底是什么？</h1><p>&emsp;&emsp;在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案；这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。设计模式不是一项技术或者一种工具，而是一种思想，而它的效果自然也因人而异。<br>&emsp;&emsp;设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象（面向对象的核心特点之一：抽象）。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。<br>&emsp;&emsp;软件行业的同仁想必都深有体会的一点就是需求永远是在变化的，正如这个世界一样唯一不变的就是变化本身，而我们要做的就是尽可能的减少变化对我们带来的冲击，所以在这种背景下，设计思路就显得尤为重要。<br>&emsp;&emsp;并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。<br>&emsp;&emsp;In software engineering, a software design pattern is a <strong>general, reusable</strong> solution to a <strong>commonly occurring problem</strong> within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. It is a description or template for how to solve a problem that can be used in many different situations. Design patterns are formalized best practices that the programmer can use to solve common problems when designing an application or system.<br>&emsp;&emsp;Object-oriented design patterns typically show relationships and interactions between classes or objects, without specifying the final application classes or objects that are involved. Patterns that imply mutable state may be unsuited for functional programming languages, some patterns can be rendered unnecessary in languages that have built-in support for solving the problem they are trying to solve, and object-oriented patterns are not necessarily suitable for non-object-oriented languages.<br>&emsp;&emsp;Design patterns may be viewed as a structured approach to computer programming intermediate between the levels of a programming paradigm and a concrete algorithm.（以上内容摘自Wiki）</p>
<h1 id="类之间的常见关系"><a href="#类之间的常见关系" class="headerlink" title="类之间的常见关系"></a>类之间的常见关系</h1><h2 id="看图识关系"><a href="#看图识关系" class="headerlink" title="看图识关系"></a>看图识关系</h2><p><div align="center"><img src="https://github.com/ttfisher/images/raw/master/2019/2019-05-23-01.jpg" width="75%"></div></p>
<ul>
<li>（关联）Association ：A类和B类有逻辑上的关系</li>
<li>（聚合）Aggregation ：A类中有一个B类作为A类不可或缺的部分</li>
<li>（组合）Composition ：A类拥有一个B类</li>
<li>（依赖）Dependency ：A类使用了B类</li>
<li>（继承）Inheritance ：B类是一个A类，或者B类扩展A类</li>
<li>（实现）Realization ：B类实现了接口A</li>
</ul>
<h2 id="关系的定义"><a href="#关系的定义" class="headerlink" title="关系的定义"></a>关系的定义</h2><h3 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h3><p>&emsp;&emsp;依赖关系是类与类之间的一种连接关系，具体体现为一个类（A）依赖于另一个类（B）的<strong>定义（仅仅是定义）</strong>；通常的表现形式是在A的某些方法参数中引用了B的定义或者直接调用了B的静态方法，也就是说通过局部变量、形参、静态方法调用形成的一种连接关系。</p>
<h3 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h3><p>&emsp;&emsp;关联关系和依赖很类似，也是类与类之间的一种连接关系，具体体现为一个类（A）依赖于另一个类（B）的<strong>属性和方法（和依赖的不同之处）</strong>；通常的表现形式是直接通过成员变量引入后的一些调用。</p>
<h3 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h3><p>&emsp;&emsp;聚合是一种非常强的关联关系，是整体和个体之间的关系；与关联关系一样，聚合关系也是通过实例变量实现的。但是关联关系涉及的两个类在同一层次，而聚合关系中两个类处在不平等的层次上，一个代表整体，一个代表部分。</p>
<h3 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h3><p>&emsp;&emsp;组合是一种比聚合还要强的关联关系，组合中的部分类是不能脱离整体类独立存在的（比如：人和大脑的关系）；在组合关系中整体和部分是有着相同的生命周期的，一旦整体消亡那么部分也就不存在了。</p>
<h3 id="继承-泛化（Inheritance）"><a href="#继承-泛化（Inheritance）" class="headerlink" title="继承/泛化（Inheritance）"></a>继承/泛化（Inheritance）</h3><p>&emsp;&emsp;继承和泛化其实是一个互逆过程，继承是从父生成子的过程，而泛化则是从子抽象出父的过程；继承表示的是子是一个父（也就是说他有父的特性），而泛化实际上是子和父相似，但却表现出更特别的行为（比如重载，也就是说他不完全和父相同）。</p>
<h3 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h3><p>&emsp;&emsp;实现在日常开发中属于比较常用的关系了，一个类实现了一个或多个接口，这是一种比继承关系稍弱的关联关系，实际上也可以当做继承的一种方式来理解。</p>
<h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><p><img style="clear: both;display: block;margin:auto;" src="https://github.com/ttfisher/images/raw/master/2018/2018-08-19-01.jpg" width="50%"><br>&emsp;&emsp;本图就很清晰的展示了设计模式的6大原则，这个原则也被简称为SOLID（首字母组合），这也是我们软件开发设计者们的目标；那么具体每个原则对应的都需要我们注意些什么呢？</p>
<ul>
<li>单一职责原则：需要我们保证类的职责要单一；各人自扫门前雪，莫管他人瓦上霜；</li>
<li>里氏替换原则：需要我们保证不破坏继承体系，子必是一个父，但是父不完全可替代子；龙生龙凤生凤，老鼠的儿子会打洞；</li>
<li>依赖倒置原则：需要我们尽量要面向接口编程，依赖抽象而非具体细节；你只需要知道我会干什么，具体我怎么干的不用你操心；</li>
<li>接口隔离原则：需要我们的接口设计粒度细化，保证被引用时只提供最小接口集；我只给你看到对你有用的，免得浪费大家的资源；</li>
<li>迪米特法则：需要我们降低耦合度，不需要的坚决不引入；不要和陌生人说话，谁知道他有没有危险；</li>
<li>开闭原则：作为六大原则的总纲，需要我们时刻注意对扩展开放，对修改关闭；你可以随便加，但改那就要通过很多人表决了；</li>
</ul>
<h2 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle, SRP)"></a>单一职责原则(Single Responsibility Principle, SRP)</h2><p>&emsp;&emsp;单一职责原则是最基础也是最简单的原则，但实际实践时有时也会是很难区分的一个原则；它的核心要求就是一个类只负责一个功能领域中的相应职责，或者稍微理论一些的说法：就一个类而言，应该只有不超过一个引起它变化的原因。</p>
<h2 id="里氏代换原则（Liskov-Substitution-Principle，LSP）"><a href="#里氏代换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle，LSP）"></a>里氏代换原则（Liskov Substitution Principle，LSP）</h2><p>&emsp;&emsp;里氏代换原则的核心就是继承的思想，只要是基类可以出现的地方，子类就一定可以出现。它是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。<br>&emsp;&emsp;里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化（基类）和具体实现（子类）的关系，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<h2 id="依赖倒转原则（Dependence-Inversion-Principle，DIP）"><a href="#依赖倒转原则（Dependence-Inversion-Principle，DIP）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle，DIP）"></a>依赖倒转原则（Dependence Inversion Principle，DIP）</h2><p>&emsp;&emsp;这个原则是开闭原则的基础，具体内容：抽象不应该依赖于细节，细节应当依赖于抽象；针对接口编程，而不是针对实现编程。<br>&emsp;&emsp;比如我们在设计程序的时候，尽量依赖于接口或者抽象类而不是去直接依赖引用实现类，这个在Spring的DI（Dependency Injection）上体现的也是相当的到位，所有的注入都尽量依赖于抽象，定义时使用抽象类型，运行时才会使用到具体的实现类型。</p>
<h2 id="接口隔离原则（Interface-Segregation-Principle，IP）"><a href="#接口隔离原则（Interface-Segregation-Principle，IP）" class="headerlink" title="接口隔离原则（Interface Segregation Principle，IP）"></a>接口隔离原则（Interface Segregation Principle，IP）</h2><p>&emsp;&emsp;这个原则的意思是：使用多个隔离的接口，比使用单个接口要好（接口的粒度要细化）。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。<br>&emsp;&emsp;实际上也就是说客户端（或者说调用方）尽量只需要依赖它用到的接口，而不应该依赖那些它不需要的接口。</p>
<h2 id="迪米特法则（Demeter-Principle，DP）"><a href="#迪米特法则（Demeter-Principle，DP）" class="headerlink" title="迪米特法则（Demeter Principle，DP）"></a>迪米特法则（Demeter Principle，DP）</h2><p>&emsp;&emsp;又称最少知道原则；最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<h2 id="开闭原则（Open-Close-Principle，OCP）"><a href="#开闭原则（Open-Close-Principle，OCP）" class="headerlink" title="开闭原则（Open Close Principle，OCP）"></a>开闭原则（Open Close Principle，OCP）</h2><p>&emsp;&emsp;开闭原则的意思是：对扩展开放，对修改关闭。尽量在不修改原有代码的情况下实现功能的扩展；所以抽象化也是开闭原则的关键。</p>
<h1 id="设计模式有哪些类别？"><a href="#设计模式有哪些类别？" class="headerlink" title="设计模式有哪些类别？"></a>设计模式有哪些类别？</h1><p><img style="clear: both;display: block;margin:auto;" src="https://github.com/ttfisher/images/raw/master/2018/2018-08-19-02.jpg" width="60%"></p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>&emsp;&emsp;这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<ul>
<li>工厂模式（Factory Method Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>单例模式（Singleton Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>&emsp;&emsp;这些设计模式关注类和对象的组合，解决怎样组装现有的类的问题，设计类之间不同的交互方式，从而实现特定的目的（有点抽象！！！）。</p>
<ul>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>装饰器模式（Decorator Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ul>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>&emsp;&emsp;这些设计模式特别关注对象之间的通信，通过类继承或者组合划分类与对象间的职责，从而应对需求变化对多个交互的对象带来的冲击（也有点抽象！！！）。</p>
<ul>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>模板模式（Template Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
</ul>
<h1 id="23种设计模式通俗演绎"><a href="#23种设计模式通俗演绎" class="headerlink" title="23种设计模式通俗演绎"></a>23种设计模式通俗演绎</h1><p>&emsp;&emsp;以下内容来源于网络（可能有些年头了），用了不同的两种方式来演绎各种设计模式的特点，在幽默诙谐的同时也不失技术研究的严谨和理性，颇值得一看。</p>
<style>
table th:first-of-type {
    width: 12%;
}
table th:nth-of-type(2) {
    width: 43%;
}
</style>

<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">故事版</th>
<th style="text-align:left">理论版</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FACTORY</td>
<td style="text-align:left">&emsp;&emsp;追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory。</td>
<td style="text-align:left">&emsp;&emsp;客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</td>
</tr>
<tr>
<td style="text-align:center">BUILDER</td>
<td style="text-align:left">&emsp;&emsp;MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）</td>
<td style="text-align:left">&emsp;&emsp;将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</td>
</tr>
<tr>
<td style="text-align:center">FACTORY METHOD</td>
<td style="text-align:left">&emsp;&emsp;请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。</td>
<td style="text-align:left">&emsp;&emsp;核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</td>
</tr>
<tr>
<td style="text-align:center">PROTOTYPE</td>
<td style="text-align:left">&emsp;&emsp;跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）</td>
<td style="text-align:left">&emsp;&emsp;通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</td>
</tr>
<tr>
<td style="text-align:center">SINGLETON</td>
<td style="text-align:left">&emsp;&emsp;俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事)。</td>
<td style="text-align:left">&emsp;&emsp;单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。</td>
</tr>
<tr>
<td style="text-align:center">ADAPTER</td>
<td style="text-align:left">&emsp;&emsp;在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)。</td>
<td style="text-align:left">&emsp;&emsp;把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</td>
</tr>
<tr>
<td style="text-align:center">BRIDGE</td>
<td style="text-align:left">&emsp;&emsp; 早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了</td>
<td style="text-align:left">&emsp;&emsp;将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。</td>
</tr>
<tr>
<td style="text-align:center">COMPOSITE</td>
<td style="text-align:left">&emsp;&emsp;Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？</td>
<td style="text-align:left">&emsp;&emsp; 合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</td>
</tr>
<tr>
<td style="text-align:center">DECORATOR</td>
<td style="text-align:left">&emsp;&emsp;Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</td>
<td style="text-align:left">&emsp;&emsp;装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</td>
</tr>
<tr>
<td style="text-align:center">FACADE</td>
<td style="text-align:left">&emsp;&emsp;我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。</td>
<td style="text-align:left">&emsp;&emsp;外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</td>
</tr>
<tr>
<td style="text-align:center">FLYWEIGHT</td>
<td style="text-align:left">&emsp;&emsp;每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。</td>
<td style="text-align:left">&emsp;&emsp; FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</td>
</tr>
<tr>
<td style="text-align:center">PROXY</td>
<td style="text-align:left">&emsp;&emsp;跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</td>
<td style="text-align:left">&emsp;&emsp;代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</td>
</tr>
<tr>
<td style="text-align:center">CHAIN OF RESPONSIBLEITY</td>
<td style="text-align:left">&emsp;&emsp;晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!</td>
<td style="text-align:left">&emsp;&emsp;在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</td>
</tr>
<tr>
<td style="text-align:center">COMMAND</td>
<td style="text-align:left">&emsp;&emsp;俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。”，:-(</td>
<td style="text-align:left">&emsp;&emsp;命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</td>
</tr>
<tr>
<td style="text-align:center">INTERPRETER</td>
<td style="text-align:left">&emsp;&emsp; 俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。</td>
<td style="text-align:left">&emsp;&emsp; 给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</td>
</tr>
<tr>
<td style="text-align:center">ITERATOR</td>
<td style="text-align:left">&emsp;&emsp;我爱上了Mary，不顾一切的向她求婚。<code>Mary：“想要我跟你结婚，得答应我的条件”；我：“什么条件我都答应，你说吧”；Mary：“我看上了那个一克拉的钻石”；我：“我买，我买，还有吗？”；Mary：“我看上了湖边的那栋别墅”；我：“我买，我买，还有吗？”；Mary：“你的小弟弟必须要有50cm长”；我脑袋嗡的一声，坐在椅子上，一咬牙：“我剪，我剪，还有吗？”；……</code></td>
<td style="text-align:left">&emsp;&emsp;迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</td>
</tr>
<tr>
<td style="text-align:center">MEDIATOR</td>
<td style="text-align:left">&emsp;&emsp;四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</td>
<td style="text-align:left">&emsp;&emsp;调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</td>
</tr>
<tr>
<td style="text-align:center">MEMENTO</td>
<td style="text-align:left">&emsp;&emsp;同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</td>
<td style="text-align:left">&emsp;&emsp;备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</td>
</tr>
<tr>
<td style="text-align:center">OBSERVER</td>
<td style="text-align:left">&emsp;&emsp;想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦！</td>
<td style="text-align:left">&emsp;&emsp;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</td>
</tr>
<tr>
<td style="text-align:center">STATE</td>
<td style="text-align:left">&emsp;&emsp;跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。</td>
<td style="text-align:left">&emsp;&emsp;状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</td>
</tr>
<tr>
<td style="text-align:center">STRATEGY</td>
<td style="text-align:left">&emsp;&emsp;跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。</td>
<td style="text-align:left">&emsp;&emsp;策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</td>
</tr>
<tr>
<td style="text-align:center">TEMPLATE METHOD</td>
<td style="text-align:left">&emsp;&emsp;看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；</td>
<td style="text-align:left">&emsp;&emsp;模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</td>
</tr>
<tr>
<td style="text-align:center">VISITOR</td>
<td style="text-align:left">&emsp;&emsp;情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</td>
<td style="text-align:left">&emsp;&emsp;访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</td>
</tr>
</tbody>
</table>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>
    
    <div>
	  
		  <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">
            ------<i class="fa fa-copyright">2019<a style="font-family:Microsoft YaHei;color:#9D9D9D;border-bottom:none;" href="https://ttfisher.github.io/" title="Lin.C的个人主页"> Lin.C </a></i>------
        </div>
    
</div>
	  
    </div>
    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/设计模式/" rel="tag"># 设计模式</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/261fb14d.html" rel="next" title="Java第三方工具系列（一）：log4j">
                <i class="fa fa-chevron-left"></i> Java第三方工具系列（一）：log4j
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/29de2e1f.html" rel="prev" title="设计模式扫盲系列（二）：创建型模式集">
                设计模式扫盲系列（二）：创建型模式集 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://pm4hdun71.bkt.clouddn.com/img/00-head.jpg" alt="Lin.C">
          <p class="site-author-name" itemprop="name">Lin.C</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">74</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ttfisher" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式到底是什么？"><span class="nav-number">1.</span> <span class="nav-text">设计模式到底是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类之间的常见关系"><span class="nav-number">2.</span> <span class="nav-text">类之间的常见关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#看图识关系"><span class="nav-number">2.1.</span> <span class="nav-text">看图识关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系的定义"><span class="nav-number">2.2.</span> <span class="nav-text">关系的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖（Dependency）"><span class="nav-number">2.2.1.</span> <span class="nav-text">依赖（Dependency）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联（Association）"><span class="nav-number">2.2.2.</span> <span class="nav-text">关联（Association）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚合（Aggregation）"><span class="nav-number">2.2.3.</span> <span class="nav-text">聚合（Aggregation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合（Composition）"><span class="nav-number">2.2.4.</span> <span class="nav-text">组合（Composition）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承-泛化（Inheritance）"><span class="nav-number">2.2.5.</span> <span class="nav-text">继承/泛化（Inheritance）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现（Realization）"><span class="nav-number">2.2.6.</span> <span class="nav-text">实现（Realization）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式的六大原则"><span class="nav-number">3.</span> <span class="nav-text">设计模式的六大原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单一职责原则-Single-Responsibility-Principle-SRP"><span class="nav-number">3.1.</span> <span class="nav-text">单一职责原则(Single Responsibility Principle, SRP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#里氏代换原则（Liskov-Substitution-Principle，LSP）"><span class="nav-number">3.2.</span> <span class="nav-text">里氏代换原则（Liskov Substitution Principle，LSP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#依赖倒转原则（Dependence-Inversion-Principle，DIP）"><span class="nav-number">3.3.</span> <span class="nav-text">依赖倒转原则（Dependence Inversion Principle，DIP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口隔离原则（Interface-Segregation-Principle，IP）"><span class="nav-number">3.4.</span> <span class="nav-text">接口隔离原则（Interface Segregation Principle，IP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迪米特法则（Demeter-Principle，DP）"><span class="nav-number">3.5.</span> <span class="nav-text">迪米特法则（Demeter Principle，DP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开闭原则（Open-Close-Principle，OCP）"><span class="nav-number">3.6.</span> <span class="nav-text">开闭原则（Open Close Principle，OCP）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式有哪些类别？"><span class="nav-number">4.</span> <span class="nav-text">设计模式有哪些类别？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建型模式"><span class="nav-number">4.1.</span> <span class="nav-text">创建型模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构型模式"><span class="nav-number">4.2.</span> <span class="nav-text">结构型模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#行为型模式"><span class="nav-number">4.3.</span> <span class="nav-text">行为型模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23种设计模式通俗演绎"><span class="nav-number">5.</span> <span class="nav-text">23种设计模式通俗演绎</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lin.C</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.1"></script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

</body>
</html>
