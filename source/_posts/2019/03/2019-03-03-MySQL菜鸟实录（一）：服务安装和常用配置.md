---
title: MySQL菜鸟实录（一）：服务安装和常用配置
categories:
  - 缓存&消息&数据库
  - MySQL实战
tags:
  - MySQL
comments: true
abbrlink: d62bf25b
date: 2019-03-03 09:40:43
---
【引言】于我而言，MySQL真的是个熟悉又陌生的领域，说熟悉是因为从刚开始做开发就接触到它，说陌生实则这么多年，对MySQL或者说数据库这个领域还是有些微微的畏惧心理，说到底还是因为不熟，没把握，所以这就从菜鸟级别开始练着吧！
<div align=center><img src="https://github.com/ttfisher/images/raw/master/2018/2018-11-13-02.jpg" width="55%"/></div>

<!-- more -->

---
# <div align=center>常用系统的服务安装</div>
---

## CentOS 7

### 基本信息
- 系统版本： CentOS 7.3 64bit
- 系统配置： 4vCPUs | 8GB
- 磁盘空间： 
```
[root@ecs-ce5a-0001 ~]# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/vda1        40G   17G   22G  44% /
devtmpfs        3.9G     0  3.9G   0% /dev
tmpfs           3.9G     0  3.9G   0% /dev/shm
tmpfs           3.9G   25M  3.8G   1% /run
tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup
tmpfs           783M     0  783M   0% /run/user/0
/dev/vdb1       493G   70M  467G   1% /data
[root@ecs-ce5a-0001 ~]# 
```

### 检查历史残留
&emsp;&emsp;使用rpm查询功能，查询本机是否有安装过MySQL（因为安装过后如果不彻底卸载的话，会导致后续安装出现一些异常问题，所以为了保险起见还是先检查一下为好）：
```
# 没有装过MySQL的主机
[root@ecs-ce5a-0001 ~]# rpm -qa|grep -i mysql
[root@ecs-ce5a-0001 ~]# 

# 之前装过MySQL的主机
[root@mserver0002 img]#  rpm -qa|grep -i mysql
mysql-community-common-5.7.24-1.el6.x86_64
mysql-community-client-5.7.24-1.el6.x86_64
mysql-community-libs-5.7.24-1.el6.x86_64
mysql-community-server-5.7.24-1.el6.x86_64
[root@mserver0002 img]#
```
&emsp;&emsp;若发现有历史安装痕迹，那么就要进行下一步的清理操作来清除历史垃圾了，挨个将所有的安装包清理完毕（若出现卸载不掉的可以尝试使用`rpm -ev `)：
```
[root@mserver0002 img]#  yum -y remove mysql-community-common-5.7.24-1.el6.x86_64
[root@mserver0002 img]#  yum -y remove xxx
```

### 下载安装源
&emsp;&emsp;MySQL有个安装源仓库站： http://repo.mysql.com/ ；里面有一大排的安装源链接，这时候可不能找错了，对应于我们此次安装的CentOS7.3版本我们选用带el7的源： http://repo.mysql.com/mysql57-community-release-el7-9.noarch.rpm ；这一步切记千万不能大意，下载的版本一旦和系统无法对应，那么接下来的所有操作都是白费工夫，而且还有可能遇到一些意想不到的问题。
```
[root@ecs-ce5a-0001 ~]# cd tmp/
[root@ecs-ce5a-0001 tmp]# ls
[root@ecs-ce5a-0001 tmp]# wget http://repo.mysql.com/mysql57-community-release-el7-9.noarch.rpm 
--2018-11-14 10:29:03--  http://repo.mysql.com/mysql57-community-release-el7-9.noarch.rpm
......
2018-11-14 10:29:04 (253 MB/s) - ‘mysql57-community-release-el7-9.noarch.rpm’ saved [9224/9224]
[root@ecs-ce5a-0001 tmp]# 
```

### 安装mysql-server
&emsp;&emsp;在经过上一步将安装源下载到本地之后，接下来就是安装了；先通过rpm将安装源安装后，就可以正式使用yum进行mysql-server的安装了（据说也可以在安装时指定installroot，没有尝试过，一般都是默认安装的），有需要确认的地方之间y就可以了；直至出现“Complete!”意味着安装顺利完成了。
```
[root@ecs-ce5a-0001 tmp]# rpm -ivh mysql57-community-release-el7-9.noarch.rpm 
warning: mysql57-community-release-el7-9.noarch.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY
Preparing...                          ################################## [100%]
Updating / installing...
   1:mysql57-community-release-el7-9  ################################# [100%]
[root@ecs-ce5a-0001 tmp]# 
[root@ecs-ce5a-0001 tmp]# yum -y install mysql-server 
Loaded plugins: fastestmirror
Determining fastest mirrors
......

Replaced:
  mariadb-libs.x86_64 1:5.5.60-1.el7_5 

Complete!
[root@ecs-ce5a-0001 tmp]# 
```

### 默认配置查看
&emsp;&emsp;默认情况下，安装后的配置文件是下面这样子的（我们可以根据自己的需要将相应的配置补充或者进行修改，比如datadir一般都会设置到专属的数据目录下面去）：
```
[root@ecs-ce5a-0001 tmp]# vim /etc/my.cnf

[mysqld]
# ... some comments
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock

# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0

log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
```

### 启动服务
&emsp;&emsp;启动MySQL服务，当前版本的MySQL在启动时会默认生成一个root用户并提供默认密码，我们可以在`/var/log/mysqld.log `文件中获取到默认密码，至此服务正常启动完成，并获取到了默认的root密码。
```
[root@ecs-ce5a-0001 tmp]# service mysqld restart
Redirecting to /bin/systemctl restart mysqld.service
[root@ecs-ce5a-0001 tmp]# 
[root@ecs-ce5a-0001 tmp]# grep password /var/log/mysqld.log 
2018-11-14T03:07:28.036081Z 1 [Note] A temporary password is generated for root@localhost: 8-8br-HfR4J9
[root@ecs-ce5a-0001 tmp]# 
```

### 修改密码和赋权
&emsp;&emsp;使用默认密码登录后，发现啥也做不了，必须修改密码，所以使用了alter来进行密码修改（密码要求比早版本的严格了很多，长度、特殊字符、字母和数字都有要求），关于赋权，后面的补充知识里面会专门稍微详细的说明一下。
```sql
[root@ecs-ce5a-0001 tmp]# mysql -uroot -p8-8br-HfR4J9
mysql: [Warning] Using a password on the command line interface can be insecure.
......
mysql> use mysql
ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.
mysql> alter user 'root'@'localhost' identified by 'smart';  
ERROR 1819 (HY000): Your password does not satisfy the current policy requirements
mysql> alter user 'root'@'localhost' identified by 'Smart@123';
Query OK, 0 rows affected (0.00 sec)

mysql> flush privileges;
Query OK, 0 rows affected (0.00 sec)

mysql> 
```

## CentOS 6

### 无果的尝试
&emsp;&emsp;理论上来说，CentOS6和CentOS7安装MySQL的步骤应该是一致的，起码大部分的步骤都应该是一致的，但是事实上却并不如此。
&emsp;&emsp;按照传统的安装方式，即使在下载repo时选择了正确的平台版本，最后发现还是在`yum -y install mysql-server `这一步遇到了缺GLIBC_2.14的问题（类似下面这种），也曾经尝试过自己编译安装这个库，但是没有成功，既然此路不通，那何不另觅新法呢！
```
Error: Package: mysql-community-libs-5.7.17-1.el7.x86_64 (mysql57-community-dmr)
           Requires: libc.so.6(GLIBC_2.14)(64bit)
Error: Package: mysql-community-client-5.7.17-1.el7.x86_64 (mysql57-community-dmr)
           Requires: libc.so.6(GLIBC_2.14)(64bit)
Error: Package: mysql-community-client-5.7.17-1.el7.x86_64 (mysql57-community-dmr)
           Requires: libstdc++.so.6(GLIBCXX_3.4.15)(64bit)
 You could try using --skip-broken to work around the problem
```

### 另谋出路
&emsp;&emsp;既然在线安装会出问题，那么不妨试试传统的安装方式，把安装包下载到本地再手动安装呢？
&emsp;&emsp;于是就找到满足我们系统要求的版本（下载地址： https://dev.mysql.com/downloads/file/?id=481078 ），下载到本地（文件名：mysql-5.7.24-1.el6.x86_64.rpm-bundle.tar，这里的el6就是适配CentOS6的）;压缩包里有如下一堆文件：
```
Administrator@IVF21BBAA9XWLKD MINGW64 /e/暂时存放/mysql-5.7.24-1.el6.x86_64.rpm-bundle
$ ls
mysql-community-client-5.7.24-1.el6.x86_64.rpm
mysql-community-common-5.7.24-1.el6.x86_64.rpm
mysql-community-devel-5.7.24-1.el6.x86_64.rpm
mysql-community-embedded-5.7.24-1.el6.x86_64.rpm
mysql-community-embedded-devel-5.7.24-1.el6.x86_64.rpm
mysql-community-libs-5.7.24-1.el6.x86_64.rpm
mysql-community-libs-compat-5.7.24-1.el6.x86_64.rpm
mysql-community-server-5.7.24-1.el6.x86_64.rpm
mysql-community-test-5.7.24-1.el6.x86_64.rpm
```
&emsp;&emsp;接下来就分别按顺序安装common、libs、client、server四个包（其他工具包可以视情况决定是否安装）；这里的四个包也是可以一次性安装的（命令如：rpm -ivh pkg1 pkg2 pkg3 pkg4）：
```
[root@mserver0002 img]# rpm -ivh mysql-community-common-5.7.24-1.el6.x86_64.rpm
[root@mserver0002 img]# rpm -ivh mysql-community-libs-5.7.24-1.el6.x86_64.rpm
[root@mserver0002 img]# rpm -ivh mysql-community-client-5.7.24-1.el6.x86_64.rpm
[root@mserver0002 img]# rpm -ivh mysql-community-server-5.7.24-1.el6.x86_64.rpm
```
&emsp;&emsp;安装完成后，后面的操作步骤就和CentOS7没什么差异了，无非是改改配置文件，设置密码和权限之类的操作了。

## Ubuntu 16

### 先说两句
&emsp;&emsp;早几年Ubuntu的系统使用的还是挺多的，但是如今很多应用默认都是使用CentOS了，其实孰优孰劣我还真没详细比较过，不过一个比较明显的感觉呢，Ubuntu安装软件比起CentOS好像是比较简便一些，更傻瓜式一点，所以都了解一下也没什么坏处。

### 实际操作
&emsp;&emsp;鉴于下载安装个系统还是要耗费不少精力，所以这次也就偷个小懒，没有实际去验证这个操作了，但是之前因为已经装过很多次Ubuntu环境的MySQL了，结合网上的一些博客说明，大致也就以下几个步骤：
```
# 先通过如下3条命令完成安装
sudo apt-get install mysql-server
sudo apt install mysql-client
sudo apt install libmysqlclient-dev

# 然后查看一下mysql的端口监听确认服务是否正常启动
sudo netstat -tap | grep mysql
```
&emsp;&emsp;安装到这里就已经算成功了，后面的步骤又是老调重弹了（配置、密码、权限等等），所以也就不多说了。

## Windows 10

### 安装版
&emsp;&emsp;貌似在5.5或之前的版本还挺流行安装的，无非是一步步next，到最后设置个root密码，然后就万事大吉；到现在比较新的发行版好像都流行使用免安装的方式了，而且安装版的操作实际上也是小学生级的，只要稍微熟悉电脑操作的，估计装起来都不会遇到啥问题，所以这里就不多说了。
&emsp;&emsp;安装版（MSI）的下载地址： https://dev.mysql.com/downloads/windows/installer/8.0.html 。

### 免安装版

#### 下载安装源
&emsp;&emsp;参考地址： https://dev.mysql.com/downloads/file/?id=480557 ； 下载到本地：mysql-8.0.13-winx64.zip。

#### 解压安装
&emsp;&emsp;将压缩包解压到某个目录下（这里我是在虚拟机里面安装的，所以直接放在C盘根目录下了）；然后以管理员权限运行CMD，进入mysql解压目录的bin。
&emsp;&emsp;到这里理论上来说是要配置一下my.ini文件的（也就是Linux版的my.cnf文件），鉴于这次只是做简单的安装实验，所以就略去这一步操作。
&emsp;&emsp;接下来在dos窗口运行`mysqld --initialize-insecure`（注意：这里有坑，参考文章最后的常见错误提供了解决方法）
&emsp;&emsp;然后就可以install和start了，出现下面的成功日志即表示服务已经成功启动了。
```
Microsoft Windows [版本 10.0.10240]
(c) 2015 Microsoft Corporation. All rights reserved.

C:\Windows\system32>cd ../../

C:\>cd mysql-8.0.13-winx64

C:\mysql-8.0.13-winx64>cd bin

C:\mysql-8.0.13-winx64\bin>mysqld --initialize-insecure

C:\mysql-8.0.13-winx64\bin>mysqld -install
Service successfully installed.

C:\mysql-8.0.13-winx64\bin>net start mysql
MySQL 服务正在启动 ..
MySQL 服务已经启动成功。

C:\mysql-8.0.13-winx64\bin>

```

#### 安装结果验证
&emsp;&emsp;在前面的安装操作中我们一直没有设置root密码，所以在验证之前我们要设置一下root密码，按照下面的步骤操作即可；密码设置完成后即可登录进行常规操作，如下即表示安装成功。
```
C:\mysql-8.0.13-winx64\bin>mysqladmin -u root password Smart@123
mysqladmin: [Warning] Using a password on the command line interface can be insecure.
Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety.


C:\mysql-8.0.13-winx64\bin>mysql -uroot -p
Enter password: *********
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 10
Server version: 8.0.13 MySQL Community Server - GPL

Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> show databases ;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.01 sec)

mysql>

```

#### 补充内容
&emsp;&emsp;实际上这种免安装模式是将MySQL注册为Windows的一个服务了，通过查看服务列表我们能发现这个MySQL服务，也可以控制服务的启动方式、运行状态等等。
<img style="clear: both;display: block;margin:auto;" src="https://github.com/ttfisher/images/raw/master/2018/2018-11-14-03.jpg" width="75%">

#### 怎么卸载？
- 首先要停止当前正在运行的服务，然后删除mysql目录
- 然后打开注册表编辑器（regedit），找到并清除以下项：
> HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Services/Eventlog/Application/MySQLD Service
HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Eventlog/Application/MySQLD Service

- 最后需要删除已注册到系统中的MySQL服务
```
C:\Windows\system32>sc delete MySQL
[SC] DeleteService 成功

C:\Windows\system32>
```

## 补充知识

### 关于密码规则
&emsp;&emsp;MySQL的密码设置有不同的规则等级，具体说来是跟validate_password_policy这个配置相关的（默认是1，即MEDIUM，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符。）：

| Policy | Tests Performed |
| :----: | :-------------: |
| 0 or LOW | Length |
| 1 or MEDIUM | Length; numeric, lowercase/uppercase, and special characters |
| 2 or STRONG | Length; numeric, lowercase/uppercase, and special characters; dictionary file |

### 忘记密码了怎么办？
&emsp;&emsp;有时长时间不用某服务器了，猛地有一天想去看看数据却发现密码忘了，很是尴尬吧？这时候就需要用到了skip-grant-tables 这个配置了，在my.cnf中将这个配置项打开然后restart一下服务，就可以不用校验密码登录mysql服务器了，登录进去之后再给自己的root重新设置一下密码`update mysql.user set authentication_string=password('Smart@123') where user='root' ;`，大功告成！
```
[root@mserver0002 img]# cat /etc/my.cnf
[mysqld]
########basic settings########
#skip-grant-tables
default-storage-engine=INNODB
......

# 修改完配置文件后可以使用空密码登录（在Enter password:出现后直接敲enter键）
[root@ecs-ce5a-0001 etc]# mysql -uroot -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
......

mysql> use mysql

Database changed
mysql> SET PASSWORD = PASSWORD('Smart@123');
ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement
mysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'Smart@123';
ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement
mysql> update mysql.user set password=password('Smart@123') where user= 'root';
ERROR 1054 (42S22): Unknown column 'password' in 'field list'
mysql> desc mysql.user
    -> ;
+------------------------+-----------------------------------+------+-----+-----------------------+-------+
| Field                  | Type                              | Null | Key | Default               | Extra |
+------------------------+-----------------------------------+------+-----+-----------------------+-------+
| Host                   | char(60)                          | NO   | PRI |                       |       |
......
| authentication_string  | text                              | YES  |     | NULL                  |       |
| password_expired       | enum('N','Y')                     | NO   |     | N                     |       |
| password_last_changed  | timestamp                         | YES  |     | NULL                  |       |
| password_lifetime      | smallint(5) unsigned              | YES  |     | NULL                  |       |
| account_locked         | enum('N','Y')                     | NO   |     | N                     |       |
+------------------------+-----------------------------------+------+-----+-----------------------+-------+
45 rows in set (0.00 sec)

mysql> update mysql.user set authentication_string=password('Smart@123') where user= 'root';
Query OK, 1 row affected, 1 warning (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 1

mysql> FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.01 sec)

mysql> exit
Bye
[root@ecs-ce5a-0001 etc]# mysql -uroot -p
# 在这里输入新设置的密码Smart@123
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
......

mysql> 
```

### 关于赋权的说明
&emsp;&emsp;首先说说改密码，其实有下面两种途径都可以；而赋权则会涉及的比较多，可以参考下面的操作样例（关于用户权限管理，这么小小的一段是说不清楚的，后面会单独开新的章节进行详细说明）：
```
ALTER USER 'root'@'localhost' IDENTIFIED BY 'Smart@123';
flush privileges;

SET PASSWORD = PASSWORD('Smart@123');
ALTER USER 'root'@'localhost' PASSWORD EXPIRE NEVER;
flush privileges;

-- root全部赋权
grant all privileges on *.* to root@"%" identified by "Smart@123";
flush privileges;

-- 普通用户部分赋权
grant select,insert,update,delete on db_test.* to test@"%" identified by "Smart@2018";
flush privileges;
```

### 查看MySQL版本
&emsp;&emsp;有时候难免会有需要查看MySQL版本的需求（比如做库同步时要查看两个服务的版本是不是一致能不能同步之类的），下面提供了4中常用的数据库版本查看的方法：
```bash
# 方法1
[root@ecs-ce5a-0001 ~]# mysql -V
mysql  Ver 14.14 Distrib 5.7.24, for Linux (x86_64) using  EditLine wrapper

# 方法2
[root@ecs-ce5a-0001 ~]# mysql --help |grep Distrib
mysql  Ver 14.14 Distrib 5.7.24, for Linux (x86_64) using  EditLine wrapper

# 方法3
[root@ecs-ce5a-0001 ~]# mysql -uroot -pKoncendy@123
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 12
Server version: 5.7.24-log MySQL Community Server (GPL)

Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql>  select version();
+------------+
| version()  |
+------------+
| 5.7.24-log |
+------------+
1 row in set (0.00 sec)

# 方法4
mysql> status
--------------
mysql  Ver 14.14 Distrib 5.7.24, for Linux (x86_64) using  EditLine wrapper

Connection id:		12
Current database:	
Current user:		root@
SSL:			Not in use
Current pager:		stdout
Using outfile:		''
Using delimiter:	;
Server version:		5.7.24-log MySQL Community Server (GPL)
Protocol version:	10
Connection:		Localhost via UNIX socket
Server characterset:	utf8
Db     characterset:	utf8
Client characterset:	utf8
Conn.  characterset:	utf8
UNIX socket:		/data/mysql/mysql.sock
Uptime:			5 min 21 sec

Threads: 6  Questions: 293  Slow queries: 6  Opens: 195  Flush tables: 1  Open tables: 156  Queries per second avg: 0.912
--------------

mysql> 
```

### 常见的错误

#### 远程无法访问
&emsp;&emsp;通常情况下，有两个可能性比较大的原因：
- bind-address没设置对，端口绑定到127.0.0.1上面去了
- 云服务器的3306端口没有做安全组规则开放（这个在本地服务器安装不会出现）

#### 目录初始化问题
&emsp;&emsp;启动时失败通过`journalctl -xe`查看发现如下的错入日志，一般出现这个错误表示my.cnf里指定的datadir不是一个空目录（有垃圾文件或者有之前初始化残留的文件）；已经初始化，但没有成功，想再次初始化报错；这时需要清理这个目录之后重新尝试启动服务。
> ...: 2018-11-14T13:43:11.806347+08:00 0 [ERROR] --initialize specified but the data directory has files in it. Aborting.

#### 日志权限的问题
&emsp;&emsp;启动时失败通过`journalctl -xe`查看发现如下的错入日志，实际上就是写日志文件没有权限导致的错误。但是我在执行了`[root@ecs-ce5a-0001 etc]# chmod -R 766 /var/log/mysql`之后发现启动服务后还是会报下面的错误，很奇怪（因为766已经对应的是`-rwxrw-rw-`这个权限级别，可以读写了）；后来将766调整为777才可以正常启动服务。（没完全弄明白为什么对日志目录要执行权限？）
> ...: 2018-11-14T13:44:17.230008+08:00 0 [ERROR] Could not open file '/var/log/mysql/error.log' for error logging: Permission denied

#### MSVCP140.dll缺失
&emsp;&emsp;windows下出现的，在dos窗口运行`mysqld --initialize-insecure`，这时出现如下提示：
```
---------------------------
mysqld.exe - 系统错误
---------------------------
无法启动此程序，因为计算机中丢失 MSVCP140.dll。尝试重新安装该程序以解决此问题。 
---------------------------
确定   
---------------------------
```
&emsp;&emsp;实际上这个问题是因为没有安装VC++2015版运行库导致的（Microsoft Visual C++ 2015 Redistributable），到如下下载地址 https://www.microsoft.com/en-us/download/details.aspx?id=53587 ，按照本机操作系统的位数确定下载的包，安装后即可解决此问题。

---
# <div align=center>核心配置文件my.cnf解密</div>
---


## my.cnf的由来
&emsp;&emsp;常用windows平台的同学可能更熟悉的是my.ini文件，my.cnf则是linux平台上的MySQL配置文件，实际上这俩是一回事儿，不过是不同平台下的命名不一样而已。
&emsp;&emsp;大部分的情况下，安装完成MySQL服务后都会生成这个my.cnf文件，一般是需要放在/etc这个目录下的，之前在网上有看过说使用rpm包安装是不会默认生成的，这个倒是没验证过。

## my.cnf的配置细节
``` 

#------------------------------------------------------------------#
#  客户端相关的配置，在使用mysql命令行连接时，会使用此处的参数
#------------------------------------------------------------------#

[client]
# 连接端口，默认都是3306　　　　　　　　　　　　　　　
port = 3306　　　　　
# 本地连接时会用到的的socket套接字；
socket = /data/mysql/3306/mysql.sock  
# 编码（关于MySQL内部的编码有很多配置项，后面单独分析一下）
default-character-set = utf8mb4　　　　　　　

#------------------------------------------------------------------#
#  服务端配置
#------------------------------------------------------------------#

[mysqld] 

#------------------------------------------------------------------#
#  服务端的一些常规配置项（比如：IP、Port之类的）
#------------------------------------------------------------------#

# 服务监听端口（通常为了安全考虑生产环境不建议使用默认的3306端口的）
port = 3306 
# 端口监听的远程绑定地址（以前偶尔会遇到默认绑定到127.0.0.1，然后远程无法连接的问题，就是这个配置项导致的）；也就是说3306端口对哪些地址是开放的（当业务主机固定时可考虑在这边缩小绑定范围），配0.0.0.0也就是敞开大门不做限制了
bind-address = 0.0.0.0
# 本机的ID（单机无所谓，多机则需要区分；类似kafka的broker-id）
server-id = 1 
# 服务启动用户（好像很少用到，可能类似于nginx的user配置项，会涉及一些用户目录权限的控制）
user = mysql

#------------------------------------------------------------------#
#  一些与本地磁盘存储路径相关的设置
#------------------------------------------------------------------#

# 本地通讯套接字文件（和客户端配置保持一致，保证两段的通信正常）
socket = /data/mysql/3306/mysql.sock　　  
# pid文件路径（用于记录mysqld进程的Process ID）；不配置的话默认存储到数据目录，以"主机名.pid"命名
pid-file = /data/mysql/3306/mysql.pid　　
# Path to installation directory. All paths are usually resolved relative to this.
basedir = /usr/local/mysql-5.7.11　
# Path to the database root. 实际的数据文件的存储目录　　　　　
datadir = /data/mysql/3306/data　　　
# 临时文件目录，存放运行时生成的一些临时文件　　
tmpdir = /data/mysql/3306/tmp

#------------------------------------------------------------------#
#  服务端编码相关设置
#------------------------------------------------------------------#

character_set_server = utf8mb4
collation_server = utf8mb4_bin
　　　　　　　　　　　　　
#------------------------------------------------------------------#
#  skip相关的配置
#------------------------------------------------------------------#

# 控制在启动mysql时不启动grant-tables（授权表），通常在忘记密码的情况下有用
skip-grant-tables

# 开启此选项可以关闭MySQL对外部连接的DNS解析（包括域名和主机名），有效的提升连接效率，但需注意一旦开启该选项，所有远程主机的连接授权都要使用IP地址方式而不能用主机名了（对应mysql的user、db、tables_priv、columns_priv等表的Host），否则可能出现1045的Error
skip-name-resolve 

# 禁用主机名缓存（The host cache is enabled by default.），一般和前面的DNS禁用配合使用。当然也可以通过如下手段手动清除主机名缓存：FLUSH HOSTS语句或mysqladmin flush-hosts命令。
skip-host-cache

# 【默认开启】此选项开启后将禁止对表使用软连接；表的软连接只有MyISAM支持，开启表软连接后（尤其是对于使用系统root用户启动MySQL服务的），MySQL用户就可以使用mysqld来删除、重命名数据文件所在位置以外的文件了（安全隐患很大）
skip-symbolic-links 

# 跳过外部锁定，External-locking用于多进程条件下为MyISAM数据表进行锁定，当外部锁定（external-locking）开启时，每个进程若要访问数据表，则必须等待之前的进程完成操作并解除锁定。由于服务器访问数据表时经常需要等待解锁，因此在单服务器环境下external locking会让MySQL性能下降。所以在很多Linux发行版的源中，MySQL配置文件中默认使用了skip-external-locking来避免external locking。但如果你有多台服务器使用同一个数据库目录（不建议），那么每台服务器都必须开启external locking；老版本配置项为skip-locking
skip-external-locking 

# 启动mysql时不同步启动复制进程，主要用在master-slave时，因为mysql默认是自动启动复制进程的，在某些特殊的数据恢复之类的场景下，若自动启动很可能导致数据不一致等异常问题的出现
skip-slave-start 

# 本选项用于彻底关闭MySQL的TCP/IP连接方式，一旦关闭就相当于禁止了远程连接，一般仅在业务服务和数据库服务都在一台服务器上直接本地连接时才会出于安全考虑开启，但是很少会有这种部署方式
skip-networking 

#------------------------------------------------------------------#
#  系统资源相关
#------------------------------------------------------------------#

# 设定MySQL所允许的最大连接数；在连接数不够用时会经常出现"Too Many Connections"的Error，这时就需要检查是否需要扩大这个配置了。
max_connections = 1000 

# 限制每个用户的session连接个数，不同用户间不交叉生效
max_user_connections = 3

# 针对某个用户，若由其发起的连接出现的error数超过该值，则该用户的下次连接将直接被阻塞，直到管理员执行flush hosts命令或者mysql服务重启（主要是出于对服务的安全保护）
max_connect_errors = 10000

# 连接超时时间上限（秒）,超过时间未连接成功则算超时（返回错误握手协议）；在Linux平台上，该超时也用作等待服务器首次回应的时间
connect-timeout = 10 

# 服务器关闭非交互连接之前等待活动的秒数；当某个connection空闲超过此限制（秒）时，主动关闭该connection（默认配置;8hour)
wait-timeout = 28800 

# 服务器关闭交互式连接前等待活动的秒数；交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。有些地方说这个取代了wait_timeout是不准确的。针对前端短连接时建议缩小这两个配置值，若采用长连接，可直接不配置（使用默认值8hour）
interactive-timeout = 28800 

# mysql主从复制时，master和slave之间的网络中断，slave在超过slave_net_timeout秒都没有从master服务器收到数据后，才会认为网络出现故障，然后才会重连master并且补充同步这段时间的数据。
slave-net-timeout = 600 

# 从服务器读取/写入信息的超时（比如针对写入：The number of seconds to wait for a block to be written to a connection before aborting the write.）；一个SQL执行时间过长出现中断一般是因为这两个参数导致的
net_read_timeout = 30 
net_write_timeout = 60 

# 如果某通信端口的读操作中断了，在放弃前重试多次（和net_write_timeout配合使用）
net_retry_count = 10 

# 可以理解为请求缓存队列，比如超过max_connections后的连接请求（没建立 tcp 连接）会放入此队列，大小为1/4M（每个连接256kb），这个是会占用物理内存的（所以很显然不能超过物理内存现在）。默认值就是50。对于Linux系统推荐设置为小于512的整数。如果系统在一个短时间内有很多连接，则需要增大该参数的值。
back_log = 50 

# 请求包消息缓冲区初始化大小（单位：字节，也可以自带单位比如16M），因为这个配置值不大，所以在实际需要时会自动增长到max_allowed_packet的限制值
net_buffer_length = 16384 

# 【默认值16M】服务所能处理的请求包的最大大小（当与大的BLOB字段一起工作时相当必要），限制了mysql服务server可以接受的数据包大小，避免超长SQL的执行有问题 
，当MySQL客户端或mysqld服务器收到大于max_allowed_packet字节的信息包时，将发出“信息包过大”错误，并关闭连接。
max_allowed_packet = 64M

# 所有线程可打开表的总数量. 这个值和open-files-limit的配置是相关联的，最大也不可以超过open-files-limit的限制
table_cache = 512 

# 线程使用的堆内存大小，此容量的内存在每次连接时被预留，默认设置足以满足大多数应用，一般不会调整除非有需要使用大量堆内存的操作
thread_stack = 192K 

# 相当于线程池的大小，和java的newCachedThreadPool原理类似（优先从线程池获取空闲线程，用完返还；若获取不到新创建了线程，则只要不超过线程池限制则线程用完即加入线程池中）；推荐的配置规则（根据物理内存）：1G  —> 8、2G  —> 16、3G  —> 32、大于3G  —> 64
thread_cache_size = 20 

# 字面理解是控制并发线程数的，涉及到并发自然就跟CPU相关（虽然是多线程并发，但具体的一个时间片一个CPU，准确说是一个核只能运行一个线程），这里说的CPU是逻辑CPU（比如：2颗双核CPU的基数就是4），该参数的建议取值为服务器逻辑CPU数量×2，比如刚刚提到的2颗双核CPU的话，建议配置就是2*2*2=8；此参数非常重要（配置不合理会导致不能充分利用多核CPU的优势）
thread_concurrency = 8 

#------------------------------------------------------------------#
#  查询缓存相关配置
#------------------------------------------------------------------#

# 查询缓冲区中缓存的查询结果大小上限，只有小于此值的结果才会被缓冲（主要是用来保护查询缓冲区，防止大的结果集将其他所有的查询结果覆盖而失去了缓冲的意义）
query_cache_limit = 2M 

# 查询缓存分配的最小块大小.默认是 4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费
query_cache_min_res_unit = 2K 

# 指定 MySQL 查询缓冲区的大小
query_cache_size = 64M  

#------------------------------------------------------------------#
#  日志相关配置
#------------------------------------------------------------------#

# 启用binlog，并指定文件名；在以下场景通常需要开放此配置：主从时的Master服务器必须配置；有从数据库最后备份中做基于时间点的恢复需求时也需要配置。本路径是datadir的相对路径；数据库服务最终会在datadir下生成名如"mysql-bin.nnnnnn"的文件。
log-bin = mysql-bin

# 指定开启哪个库的binlog
binlog-do-db = test1

# 配置binlog的索引文件名（也是datadir的相对路径）
log-bin-index = mysql-bin.index 

# 作为Slave的服务器在同步数据时会将同步事件也写入自己的binlog，这个选项通常在一个服务器担任两个角色时需要启用（比如：A-B-C模式，B服务器作为A的Slave，同时作为C的Master）
log_slave_updates = 1 

# 配置relay-log的位置（也是datadir的相对路径）和文件名（默认值host_name-relay-bin.nnnnnn）；relay_log是和binlog类似的存在，Slave服务器会有同步线程将Master的binlog同步过来到自己的relay-log，同时Slave服务器也会有一个sql执行线程将relay-log的日志内容读取并应用到Slave服务器，从而完成数据同步。
relay-log = relay-log 

# 配置relay-log的索引文件名（也是datadir的相对路径）
relay_log_index = relay-log.index  

# 错误日志路径（绝对路径，需要有写权限）
log-error =  /usr/local/mysql/log/mysql.err 

# 将警告信息打印到错误日志文件（便于一些问题的排查）；取值：0-不记录警告信息，1-记录警告信息（默认），大于1-连接失败、拒绝访问等错误信息也会记录
log-warnings = 1 

# 是否开启慢查询日志，The value can be 0 (or OFF) to disable the log or 1 (or ON) to enable the log. （同：log_slow_queries）
slow_query_log = 1 

# 设定慢查询的阀值（默认10s），注意不要用1，因为MySQL时间精确度只能到秒级，为1的话所有查询都会被当做慢查询
long-query-time = 10 

# 慢查询日志的输出格式；取值：TABLE（slow_log表）、FILE（文件）、NONE（不输出）
log_output = FILE 

# 在慢查询日志中记录更多信息，打开此项时没有使用索引的查询也会写到慢查询日志中
log_long_format 

# 慢查询日志文件路径（默认为：host_name-slow.log）
slow_query_log_file =  /data/mysql/log/my-slow.log 

# 对未使用索引的查询语句，也记录到慢查询日志中
log-queries-not-using-indexes 

# 查询中返回的记录若超过此限制，则被记录到慢查询日志中
min_examined_row_limit=1000　　　　

# 将操作慢的optimize table，analyze table和alter table语句也记录到慢查询日志中
long-slow-admin-statements　　　　

# 将由Slave所产生的慢查询记录到慢查询日志中
log-slow-slave-statements 

# 记录MySQL Server接收到的所有SQL语句（默认关闭）
general_log = 1 

# general_log日志存储路径
general_log_file =  /usr/local/mysql/log/mysql.log 

# binlog的大小上限，超过这个设置就会“closes the current file and opens the next one”；取值区间4096-1073741824（4K-1G）
max_binlog_size = 1G 

# relaylog的大小上限（若配置为0，则取max_binlog_size的值）
max_relay_log_size = 1G 

# 是否自动清空不再需要的relay-log（默认为1-启用）
relay-log-purge = 1 

# binlog的过期删除天数（超过30天的binlog自动被删除）
expire_logs_days = 30 

# binlog在一个事务中为了记录SQL状态所配置的缓存区大小
binlog_cache_size = 1M 

# 在Slave服务器设置，Slave复制时指定复制哪些表
replicate-wild-do-table = db_name.%

# 在Slave服务器设置，Slave复制时忽略哪些表（需要指定多个时可配置多条）
replicate-wild-ignore-table = mysql.% 

# 在Slave服务器设置，指定复制哪些库（不推荐：跨库更新时会出错，建议用table）
replicate_do_db = db1

# 在Slave服务器设置，指定忽略哪些库（不推荐：跨库更新时会出错，建议用table）
replicate_ignore_db = mysql

# Slave复制过程中可以自动跳过的错误号，不影响后面的语句执行；四个可用值：off（默认），all，ErorCode，ddl_exist_errors
slave_skip_errors = all 

#------------------------------------------------------------------#
#  MyISAM相关配置（实际业务强烈建议不使用MyISAM引擎）
#------------------------------------------------------------------#　　　　　

# 指定用于索引的缓冲区大小，增加它可得到更好的索引处理性能。如果是以InnoDB引擎为主的DB，建议设置较小（8M），注意：设置的值过大会导致服务器整体效率降低。
key_buffer_size = 256M 

# 查询排序时可使用的缓冲区大小（ORDER BY，GROUP BY ）
sort_buffer_size = 2M 

# 查询操作可使用的缓冲区大小
read_buffer_size = 2M 

# 联合查询操作可使用的缓冲区大小，主要用来优化full JOINs不带索引的联合查询
join_buffer_size = 8M 

bulk_insert_buffer_size = 64M 
#MyISAM 使用特殊的类似树的 cache 来使得突发插入(这些插入是,INSERT … SELECT, INSERT … VALUES (…), (…), …, 以及 LOAD DATAINFILE) 更快. 此变量限制每个进程中缓冲树的字节数.设置为 0 会关闭此优化.为了最优化不要将此值设置大于 “key_buffer_size”.当突发插入被检测到时此缓冲将被分配MyISAM 用在块插入优化中的树缓冲区的大小。注释：这是一个 per thread 的限制 （ bulk 大量）.此缓冲当 MySQL 需要在 REPAIR, OPTIMIZE, ALTER 以及 LOAD DATA INFILE到一个空表中引起重建索引时被分配.这在每个线程中被分配.所以在设置大值时需要小心.

myisam_sort_buffer_size = 64M 
#MyISAM 设置恢复表之时使用的缓冲区的尺寸,当在REPAIR TABLE 或用 CREATE INDEX 创建索引或 ALTER TABLE 过程中排序 MyISAM 索引分配的缓冲区

myisam_max_sort_file_size = 10G
#mysql重建索引时允许使用的临时文件最大大小

myisam_repair_threads = 1 
#如果该值大于 1，在 Repair by sorting 过程中并行创建MyISAM 表索引(每个索引在自己的线程内).如果一个表拥有超过一个索引, MyISAM 可以通过并行排序使用超过一个线程去修复他们.这对于拥有多个 CPU 以及大量内存情况的用户,是一个很好的选择.

myisam_recover = 64K
#允许的 GROUP_CONCAT()函数结果的最大长度
transaction_isolation = REPEATABLE-READ # 设定默认的事务隔离级别.可用的级别如下:READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ,SERIALIZABLE
1.READ UNCOMMITTED-读未提交 2.READ COMMITTE-读已提交 3.REPEATABLE READ -可重复读 4.SERIALIZABLE -串行


#------------------------------------------------------------------#
#  InnoDB相关配置
#------------------------------------------------------------------#　

skip-innodb 
# 如果你的 MySQL 服务包含 InnoDB 支持但是并不打算使用的话,使用此选项会节省内存以及磁盘空间,并且加速某些部分

innodb_file_per_table = 1 
# InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间
独立表空间优点：
1．每个表都有自已独立的表空间。
2．每个表的数据和索引都会存在自已的表空间中。
3．可以实现单表在不同的数据库中移动。
4．空间可以回收（除drop table操作处，表空不能自已回收）
缺点：
1.单表增加过大，如超过100G
结论：
共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整：innodb_open_files

innodb_status_file = 1 
#启用InnoDB的status file，便于管理员查看以及监控等

innodb_open_files = 2048 
# 限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。这个值默认是300

innodb_additional_mem_pool_size = 100M 
#设置InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，所以当我们一个MySQL Instance中的数据库对象非常多的时候，是需要适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率的。 

innodb_buffer_pool_size = 2G 
#包括数据页、索引页、插入缓存、锁信息、自适应哈希所以、数据字典信息.InnoDB 使用一个缓冲池来保存索引和原始数据, 不像 MyISAM.这里你设置越大,你在存取表里面数据时所需要的磁盘 I/O 越少.在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的 80%,不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.注意在 32 位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,所以不要设置的太高.

innodb_write_io_threads = 4
innodb_read_io_threads = 4
# innodb使用后台线程处理数据页上的读写 I/O(输入输出)请求,根据你的 CPU 核数来更改,默认是4
# 注:这两个参数不支持动态改变,需要把该参数加入到my.cnf里，修改完后重启MySQL服务,允许值的范围从 1-64

innodb_data_home_dir =  /usr/local/mysql/var/ 
#设置此选项如果你希望 InnoDB 表空间文件被保存在其他分区.默认保存在 MySQL 的 datadir 中.

innodb_data_file_path = ibdata1:500M;ibdata2:2210M:autoextend
#InnoDB将数据保存在一个或者多个数据文件中成为表空间.如果你只有单个逻辑驱动保存你的数据,一个单个的自增文件就足够好了.其他情况下.每个设备一个文件一般都是个好的选择.你也可以配置 InnoDB 来使用裸盘分区 – 请参考手册来获取更多相关内容

innodb_file_io_threads = 4 
#用来同步 IO 操作的 IO 线程的数量. 此值在 Unix 下被硬编码为 4,但是在 Windows 磁盘 I/O 可能在一个大数值下表现的更好.

innodb_thread_concurrency = 16
#在 InnoDb 核心内的允许线程数量,InnoDB 试着在 InnoDB 内保持操作系统线程的数量少于或等于这个参数给出的限制,最优值依赖于应用程序,硬件以及操作系统的调度方式.过高的值可能导致线程的互斥颠簸.默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量

innodb_flush_log_at_trx_commit = 1 
#如果设置为 1 ,InnoDB 会在每次提交后刷新(fsync)事务日志到磁盘上,这提供了完整的 ACID 行为.如果你愿意对事务安全折衷, 并且你正在运行一个小的食物, 你可以设置此值到 0 或者 2 来减少由事务日志引起的磁盘 I/O
0 代表日志只大约每秒写入日志文件并且日志文件刷新到磁盘.
2 代表日志写入日志文件在每次提交后,但是日志文件只有大约每秒才会刷新到磁盘上.

innodb_log_buffer_size = 8M 
#用来缓冲日志数据的缓冲区的大小.当此值快满时, InnoDB 将必须刷新数据到磁盘上.由于基本上每秒都会刷新一次,所以没有必要将此值设置的太大(甚至对于长事务而言)

innodb_log_file_size = 500M 
#事物日志大小.在日志组中每个日志文件的大小，你应该设置日志文件总合大小到你缓冲池大小的5%~100%，来避免在日志文件覆写上不必要的缓冲池刷新行为.不论如何, 请注意一个大的日志文件大小会增加恢复进程所需要的时间.

innodb_log_files_in_group = 2 
#在日志组中的文件总数.通常来说 2~3 是比较好的.

innodb_log_group_home_dir =  /usr/local/mysql/var/
# InnoDB 的日志文件所在位置. 默认是 MySQL 的 datadir.你可以将其指定到一个独立的硬盘上或者一个 RAID1 卷上来提高其性能innodb_max_dirty_pages_pct = 90 #innodb 主线程刷新缓存池中的数据，使脏数据比例小于 90%,这是一个软限制,不被保证绝对执行.

innodb_lock_wait_timeout = 50 
#InnoDB 事务在被回滚之前可以等待一个锁定的超时秒数。InnoDB 在它自己的 锁定表中自动检测事务死锁并且回滚事务。 InnoDB 用 LOCK TABLES 语句注意到锁定设置。默认值是 50 秒

innodb_flush_method = O_DSYNC 
# InnoDB 用来刷新日志的方法.表空间总是使用双重写入刷新方法.默认值是 “fdatasync”, 另一个是 “O_DSYNC”.

innodb_force_recovery=1
# 如果你发现 InnoDB 表空间损坏, 设置此值为一个非零值可能帮助你导出你的表.从1 开始并且增加此值知道你能够成功的导出表.

innodb_fast_shutdown 
# 加速 InnoDB 的关闭. 这会阻止 InnoDB 在关闭时做全清除以及插入缓冲合并.这可能极大增加关机时间, 但是取而代之的是 InnoDB 可能在下次启动时做这些操作.


#------------------------------------------------------------------#
#  其他常用配置（默认配置、特殊配置）
#------------------------------------------------------------------#　　　　　　　　　　　　
# 该变量可以被任何存储引擎使用，当从一个已经排序的键值表中读取行时，会先从该缓冲区中获取而不再从磁盘上获取（默认值256K）
read_rnd_buffer_size = 8M 

tmp_table_size = 512M 
#临时表的最大大小，如果超过该值，则结果放到磁盘中,此限制是针对单个表的,而不是总和.

max_heap_table_size = 512M 
#独立的内存表所允许的最大容量.此选项为了防止意外创建一个超大的内存表导致永尽所有的内存资源.

default_table_type = InnoDB 
# 当创建新表时作为默认使用的表类型,如果在创建表示没有特别执行表类型,将会使用此值

default-time-zone = system 
#服务器时区

character-set-server = utf8 
#server 级别字符集

default-storage-engine = InnoDB 
#默认存储引擎

# 把NOW作为SYSDATE函数的别名，因为NOW和SYSDATE相比略有区别，NOW表示语句的开始执行时间，SYSDATE返回当前时间，在主从复制中这种差异可能会导致数据不一致，所以需要开启此项配置
# MySQL的时间函数：NOW、CURDATE、CURTIME、UNIX_TIMESTAMP、SYSDATE
sysdate-is-now = 1 

#------------------------------------------------------------------#
#  mysqldump、mysql、mysqld_safe的配置
#------------------------------------------------------------------#

[mysqldump]
quick 
#支持较大数据库的转储，在导出非常巨大的表时需要此项。增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或mysqld必须返回大的结果行时mysqld才会分配更多内存。该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。 如果你正是用大的BLOB值，而且未为mysqld授予为处理查询而访问足够内存的权限，也会遇到与大信息包有关的奇怪问题。如果怀疑出现了该情况，请尝试在mysqld_safe脚本开始增加ulimit -d 256000，并重启mysqld。

[mysql]
auto-rehash 
#允许通过 TAB 键提示

default-character-set = utf8 
#数据库字符集

connect-timeout = 3

[mysqld_safe]

# MySQL服务打开的文件描述符限制；没有被配置的时候，比较max_connections*5和操作系统的ulimit -n的值，哪个大用哪个；当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。（默认最小1024）
open_files_limit = 10240 

-------------------------------------------------------------------------------



log_bin_trust_function_creators = 1 　　　　    #This variable applies when binary logging is enabled. It controls whether stored function creators can be trusted not to create stored functions that will cause 　　　　　　　　　　　　　　　　　　　　　　 #unsafe events to be written to the binary log. If set to 0 (the default), users are not permitted to create or alter stored functions unless they have the SUPER 　　　　　　　　　　　　　　　　　　　　　　 #privilege in addition to the CREATE ROUTINE or ALTER ROUTINE privilege. 开启了binlog后，必须设置这个值为1.主要是考虑binlog安全

performance_schema = 0  　　　　　　　　　　 #性能优化的引擎，默认关闭

secure_auth = 1　　　　　　　　　　　　　　　#secure_auth 为了防止低版本的MySQL客户端(<4.1)使用旧的密码认证方式访问高版本的服务器。MySQL 5.6.7开始secure_auth 默认为启用值1

#ft_min_word_len = 1    　　　　　　　　　　　 #开启全文索引

#myisam_recover 　　　　　　　　　　　　　　  #自动修复MySQL的myisam表

explicit_defaults_for_timestamp 　　　　　　  #明确时间戳默认null方式

event_scheduler 　　　　　　　　　　　　　　  #计划任务（事件调度器）
skip-external-locking　　　　　　　　　　　　#跳过外部锁定;External-locking用于多进程条件下为MyISAM数据表进行锁定

skip-name-resolve　　　　　　　　　　　　　　#跳过客户端域名解析；当新的客户连接mysqld时，mysqld创建一个新的线程来处理请求。该线程先检查是否主机名在主机名缓存中。如果不在，线程试图解析主机名。

　　　　　　　　　　　　　　　　　　　　　　#使用这一选项以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求!

#bind-address = 127.0.0.1　　　　　　　　　　#MySQL绑定IP

skip-slave-start　　　　　　　　　　　　　　 #为了安全起见，复制环境的数据库还是设置--skip-slave-start参数，防止复制随着mysql启动而自动启动

slave_net_timeout = 30  　　　　　　　　　　　#The number of seconds to wait for more data from a master/slave connection before aborting the read. MySQL主从复制的时候，

　　　　　　　　　　　　　　　　　　　　　　 #当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。

　　　　　　　　　　　　　　　　　　　　　　　#Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据。

　　　　　　　　　　　　　　　　　　　　　　　#1.用这三个参数来判断主从是否延迟是不准确的Slave_IO_Running,Slave_SQL_Running,Seconds_Behind_Master.还是用pt-heartbeat吧。
　　　　　　　　　　　　　　　　　　　　　　　#2.slave_net_timeout不要用默认值，设置一个你能接受的延时时间。

local-infile = 0    　　　　　　　　　　　　　 #设定是否支持命令load data local infile。如果指定local关键词，则表明支持从客户主机读文件

back_log = 1024 　　　　　　　　　　　　　　#指定MySQL可能的连接数量。当MySQL主线程在很短的时间内得到非常多的连接请求，该参数就起作用，之后主线程花些时间（尽管很短）检查连接并且启动一个新线程。

　　　　　　　　　　　　　　　　　　　　　　 #back_log参数的值指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。

#sql_mode = 'PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,NO_KEY_OPTIONS,NO_TABLE_OPTIONS,NO_FIELD_OPTIONS,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'

sql_mode = NO_ENGINE_SUBSTITUTION,NO_AUTO_CREATE_USER　　#sql_mode,定义了mysql应该支持的sql语法，数据校验等!  NO_AUTO_CREATE_USER：禁止GRANT创建密码为空的用户。

　　　　　　　　　　　　　　　　　　　　　　　　　　　　 #NO_ENGINE_SUBSTITUTION 如果需要的存储引擎被禁用或未编译，可以防止自动替换存储引擎

key_buffer_size = 32M　　　　　　　　　　　　#索引块的缓冲区大小，对MyISAM表性能影响最大的一个参数.决定索引处理的速度，尤其是索引读的速度。默认值是16M，通过检查状态值Key_read_requests

　　　　　　　　　　　　　　　　　　　　　　 #和Key_reads，可以知道key_buffer_size设置是否合理

max_allowed_packet = 512M　　　　　　　　　　#一个查询语句包的最大尺寸。消息缓冲区被初始化为net_buffer_length字节，但是可在需要时增加到max_allowed_packet个字节。

　　　　　　　　　　　　　　　　　　　　　　 #该值太小则会在处理大包时产生错误。如果使用大的BLOB列，必须增加该值。
　　　　　　　　　　　　　　　　　　　　　　 #这个值来限制server接受的数据包大小。有时候大的插入和更新会受max_allowed_packet 参数限制，导致写入或者更新失败。

thread_stack = 256K　　　　　　　　　　　　　#线程缓存；主要用来存放每一个线程自身的标识信息，如线程id，线程运行时基本信息等等，我们可以通过 thread_stack 参数来设置为每一个线程栈分配多大的内存。

sort_buffer_size = 16M　　　　　　　　　　　 #是MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。

　　　　　　　　　　　　　　　　　　　　　　 #如果不能，可以尝试增加sort_buffer_size变量的大小。

read_buffer_size = 16M　　　　　　　　　　　 #是MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。

　　　　　　　　　　　　　　　　　　　　　　 #如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。

join_buffer_size = 16M　　　　　　　　　　　#应用程序经常会出现一些两表（或多表）Join的操作需求，MySQL在完成某些 Join 需求的时候（all/index join），为了减少参与Join的“被驱动表”的

　　　　　　　　　　　　　　　　　　　　　　#读取次数以提高性能，需要使用到 Join Buffer 来协助完成 Join操作。当 Join Buffer 太小，MySQL 不会将该 Buffer 存入磁盘文件，

　　　　　　　　　　　　　　　　　　　　　　#而是先将Join Buffer中的结果集与需要 Join 的表进行 Join 操作，

　　　　　　　　　　　　　　　　　　　　　　#然后清空 Join Buffer 中的数据，继续将剩余的结果集写入此 Buffer 中，如此往复。这势必会造成被驱动表需要被多次读取，成倍增加 IO 访问，降低效率。

read_rnd_buffer_size = 32M　　　　　　　　　#是MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，

　　　　　　　　　　　　　　　　　　　　　　#提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。

net_buffer_length = 16K　　　　　　　　　　 #通信缓冲区在查询期间被重置到该大小。通常不要改变该参数值，但是如果内存不足，可以将它设置为查询期望的大小。

　　　　　　　　　　　　　　　　　　　　　  #（即，客户发出的SQL语句期望的长度。如果语句超过这个长度，缓冲区自动地被扩大，直到max_allowed_packet个字节。）

myisam_sort_buffer_size = 128M　　　　　　  #当对MyISAM表执行repair table或创建索引时，用以缓存排序索引；设置太小时可能会遇到” myisam_sort_buffer_size is too small”

bulk_insert_buffer_size = 32M　　　　　　  #默认8M，当对MyISAM非空表执行insert … select/ insert … values(…),(…)或者load data infile时，使用树状cache缓存数据，每个thread分配一个；
　　　　　　　　　　　　　　　　　　　　   #注：当对MyISAM表load 大文件时，调大bulk_insert_buffer_size/myisam_sort_buffer_size/key_buffer_size会极大提升速度

thread_cache_size = 384　　　　　　　　   #thread_cahe_size线程池，线程缓存。用来缓存空闲的线程，以至于不被销毁，如果线程缓存在的空闲线程，需要重新建立新连接，

　　　　　　　　　　　　　　　　　　　　　 #则会优先调用线程池中的缓存，很快就能响应连接请求。每建立一个连接，都需要一个线程与之匹配。

query_cache_size = 0　　　　　　　　　    #工作原理： 一个SELECT查询在DB中工作后，DB会把该语句缓存下来，当同样的一个SQL再次来到DB里调用时，DB在该表没发生变化的情况下把结果从缓存中返回给Client。
　　　　　　　　　　　　　　　　　　　    #在数据库写入量或是更新量也比较大的系统，该参数不适合分配过大。而且在高并发，写入量大的系统，建系把该功能禁掉。

query_cache_type = 0　　　　　　　　　    #决定是否缓存查询结果。这个变量有三个取值：0,1,2，分别代表了off、on、demand。　　　　　　　

tmp_table_size = 1024M　　　　　　　　　　#它规定了内部内存临时表的最大值，每个线程都要分配。（实际起限制作用的是tmp_table_size和max_heap_table_size的最小值。）

　　　　　　　　　　　　　　　　　　　　　#如果内存临时表超出了限制，MySQL就会自动地把它转化为基于磁盘的MyISAM表，存储在指定的tmpdir目录下

max_heap_table_size = 512M  　　　　　　   #独立的内存表所允许的最大容量.# 此选项为了防止意外创建一个超大的内存表导致永尽所有的内存资源.

open_files_limit = 10240　　　　　　　　　 #mysql打开最大文件数

max_connections = 2000　　　　　　　　　　 #MySQL无论如何都会保留一个用于管理员（SUPER）登陆的连接，用于管理员连接数据库进行维护操作，即使当前连接数已经达到了max_connections。

　　　　　　　　　　　　　　　　　　　　　 #因此MySQL的实际最大可连接数为max_connections+1；
　　　　　　　　　　　　　　　　　　　　　 #这个参数实际起作用的最大值（实际最大可连接数）为16384，即该参数最大值不能超过16384，即使超过也以16384为准；
　　　　　　　　　　　　　　　　　　　　　 #增加max_connections参数的值，不会占用太多系统资源。系统资源（CPU、内存）的占用主要取决于查询的密度、效率等；
　　　　　　　　　　　　　　　　　　　　　 #该参数设置过小的最明显特征是出现”Too many connections”错误；

max-user-connections = 0　　　　　　　　　 #用来限制用户资源的，0不限制；对整个服务器的用户限制

max_connect_errors = 100000　　　　　　　　 #max_connect_errors是一个MySQL中与安全有关的计数器值，它负责阻止过多尝试失败的客户端以防止暴力破解密码的情况。max_connect_errors的值与性能并无太大关系。
　　　　　　　　　　　　　　　　　　　　　　#当此值设置为10时，意味着如果某一客户端尝试连接此MySQL服务器，但是失败（如密码错误等等）10次，则MySQL会无条件强制阻止此客户端连接。

table_open_cache = 5120　　　　　　　　　　#表描述符缓存大小，可减少文件打开/关闭次数；

interactive_timeout = 86400　　　　　　　　#interactive_time -- 指的是mysql在关闭一个交互的连接之前所要等待的秒数(交互连接如mysql gui tool中的连接
wait_timeout = 86400　　　　　　　　　　　　#wait_timeout -- 指的是MySQL在关闭一个非交互的连接之前所要等待的秒数

binlog_cache_size = 16M　　　　　　　　　　#二进制日志缓冲大小
　　　　　　　　　　　　　　　　　　　　　 #我们知道InnoDB存储引擎是支持事务的，实现事务需要依赖于日志技术，为了性能，日志编码采用二进制格式。那么，我们如何记日志呢？有日志的时候，就直接写磁盘？

　　　　　　　　　　　　　　　　　　　　　#可是磁盘的效率是很低的，如果你用过Nginx，，一般Nginx输出access log都是要缓冲输出的。因此，记录二进制日志的时候，我们是否也需要考虑Cache呢？

　　　　　　　　　　　　　　　　　　　　　#答案是肯定的，但是Cache不是直接持久化，于是面临安全性的问题——因为系统宕机时，Cache中可能有残余的数据没来得及写入磁盘。因此，Cache要权衡，要恰到好处：

　　　　　　　　　　　　　　　　　　　　　#既减少磁盘I/O，满足性能要求；又保证Cache无残留，及时持久化，满足安全要求。

slow_query_log = 1　　　　　　　　　　　　　#开启慢查询
long_query_time = 1　　　　　　　　　　　　#超过的时间为1s；MySQL能够记录执行时间超过参数 long_query_time 设置值的SQL语句，默认是不记录的。

log-slow-admin-statements 
log-queries-not-using-indexes　　　　　　　#记录管理语句和没有使用index的查询记录

# *** Replication related settings ***
binlog_format = ROW　　　　　　　　　　　　#在复制方面的改进就是引进了新的复制技术：基于行的复制。简言之，这种新技术就是关注表中发生变化的记录，而非以前的照抄 binlog 模式。

　　　　　　　　　　　　　　　　　　　　　 #从 MySQL 5.1.12 开始，可以用以下三种模式来实现：基于SQL语句的复制(statement-based replication, SBR)，基于行的复制(row-based replication, RBR)，

　　　　　　　　　　　　　　　　　　　　　　混合模式复制(mixed-based replication, MBR)。相应地，binlog的格式也有三种：STATEMENT，ROW，MIXED。MBR 模式中，SBR 模式是默认的。

#max_binlog_cache_size = 102400　　　　　　　　　　　　　　   # 为每个session 最大可分配的内存，在事务过程中用来存储二进制日志的缓存。
log-bin = /data/mysql/3306/binlog/mysql-bin 　　　　　　　#开启二进制日志功能，binlog数据位置
log-bin-index = /data/mysql/3306/binlog/mysql-bin.index
relay-log = /data/mysql/3306/relay/mysql-relay-bin  　　　　#relay-log日志记录的是从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，

　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　#然后SQL线程会读取relay-log日志的内容并应用到从服务器
relay-log-index = /data/mysql/3306/relay/mysql-relay-bin.index  #binlog传到备机被写道relaylog里，备机的slave sql线程从relaylog里读取然后应用到本地。

server_id = 100　　　　　　　　　　　　     #服务端ID，用来高可用时做区分
log_slave_updates = 1　　　　　　　　　　 #log_slave_updates是将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中。
expire-logs-days = 15　　　　　　　　　　 #二进制日志自动删除的天数。默认值为0,表示“没有自动删除”。启动时和二进制日志循环时可能删除。
max_binlog_size = 512M　　　　　　　　　　    #如果二进制日志写入的内容超出给定值，日志就会发生滚动。你不能将该变量设置为大于1GB或小于4096字节。 默认值是1GB。

replicate-wild-ignore-table = mysql.%　　#replicate-wild-ignore-table参数能同步所有跨数据库的更新，比如replicate-do-db或者replicate-ignore-db不会同步类似 
#replicate-wild-do-table = db_name.%　　  #设定需要复制的Table

#slave-skip-errors = 1062,1053,1146　　　　#复制时跳过一些错误;不要胡乱使用这些跳过错误的参数，除非你非常确定你在做什么。当你使用这些参数时候，MYSQL会忽略那些错误，

　　　　　　　　　　　　　　　　　　　　　#这样会导致你的主从服务器数据不一致。

auto_increment_offset = 1
auto_increment_increment = 2　　　　　　　　#这两个参数一般用在主主同步中，用来错开自增值, 防止键值冲突

 

relay_log_info_repository = TABLE　　　　　#将中继日志的信息写入表:mysql.slave_realy_log_info
master_info_repository = TABLE　　　　　　 #将master的连接信息写入表：mysql.salve_master_info
relay_log_recovery = on　　　　　　　　　　#中继日志自我修复；当slave从库宕机后，假如relay-log损坏了，导致一部分中继日志没有处理，则自动放弃所有未执行的relay-log，

　　　　　　　　　　　　　　　　　　　　　#并且重新从master上获取日志，这样就保证了relay-log的完整性

 

 

# *** innodb setting ***
innodb_buffer_pool_size = 4G　　　　　　　　#InnoDB 用来高速缓冲数据和索引内存缓冲大小。 更大的设置可以使访问数据时减少磁盘 I/O。

innodb_data_file_path = ibdata1:1G:autoextend　　#单独指定数据文件的路径与大小

innodb_flush_log_at_trx_commit = 0　　　　　　#每次commit 日志缓存中的数据刷到磁盘中。通常设置为 1，意味着在事务提交前日志已被写入磁盘， 事务可以运行更长以及服务崩溃后的修复能力。

　　　　　　　　　　　　　　　　　　　　　　　#如果你愿意减弱这个安全，或你运行的是比较小的事务处理，可以将它设置为 0 ，以减少写日志文件的磁盘 I/O。这个选项默认设置为 0。

#sync_binlog = 1000　　　　　　　　　　　　#sync_binlog=n，当每进行n次事务提交之后，MySQL将进行一次fsync之类的磁盘同步指令来将binlog_cache中的数据强制写入磁盘。

innodb_read_io_threads = 8　　
innodb_write_io_threads = 8　　　　　　　　#对于多核的CPU机器，可以修改innodb_read_io_threads和innodb_write_io_threads来增加IO线程，来充分利用多核的性能

innodb_file_format = Barracuda　　　　　　#Innodb Plugin引擎开始引入多种格式的行存储机制，目前支持：Antelope、Barracuda两种。其中Barracuda兼容Antelope格式。

innodb_open_files = 65536　　　　　　　　　#限制Innodb能打开的表的数量
innodb_purge_threads = 1　　　　　　　　　#开始碎片回收线程。这个应该能让碎片回收得更及时而且不影响其他线程的操作
innodb_support_xa = FALSE　　　　　　　　#分布式事务
innodb_log_buffer_size = 256M　　　　　　#InnoDB 将日志写入日志磁盘文件前的缓冲大小。理想值为 1M 至 8M。大的日志缓冲允许事务运行时不需要将日志保存入磁盘而只到事务被提交(commit)。

　　　　　　　　　　　　　　　　　　　　 #因此，如果有大的事务处理，设置大的日志缓冲可以减少磁盘I/O。

innodb_log_file_size = 1G　　　　　　　 #日志组中的每个日志文件的大小(单位 MB)。如果 n 是日志组中日志文件的数目，那么理想的数值为 1M 至下面设置的缓冲池(buffer pool)大小的 1/n。较大的值，

　　　　　　　　　　　　　　　　　　　　#可以减少刷新缓冲池的次数，从而减少磁盘 I/O。但是大的日志文件意味着在崩溃时需要更长的时间来恢复数据。

innodb_log_files_in_group = 3　　　　　　#指定有三个日志组

#innodb_lock_wait_timeout = 120　　　　　#在回滚(rooled back)之前，InnoDB 事务将等待超时的时间(单位 秒)

innodb_max_dirty_pages_pct = 75　　　　　#innodb_max_dirty_pages_pct作用：控制Innodb的脏页在缓冲中在那个百分比之下，值在范围1-100,默认为90.这个参数的另一个用处：

　　　　　　　　　　　　　　　　　　　　#当Innodb的内存分配过大，致使swap占用严重时，可以适当的减小调整这个值，使达到swap空间释放出来。建义：这个值最大在90%，最小在15%。

　　　　　　　　　　　　　　　　　　　　#太大，缓存中每次更新需要致换数据页太多，太小，放的数据页太小，更新操作太慢。

innodb_buffer_pool_instances = 4 　　　 #innodb_buffer_pool_size 一致 可以开启多个内存缓冲池，把需要缓冲的数据hash到不同的缓冲池中，这样可以并行的内存读写。

innodb_io_capacity = 500　　　　　　　　#这个参数据控制Innodb checkpoint时的IO能力

innodb_file_per_table = 1　　　　　　　　#作用：使每个Innodb的表，有自已独立的表空间。如删除文件后可以回收那部分空间。
　　　　　　　　　　　　　　　　　　　　 #分配原则：只有使用不使用。但ＤＢ还需要有一个公共的表空间。

innodb_change_buffering = inserts　　　　#当更新/插入的非聚集索引的数据所对应的页不在内存中时（对非聚集索引的更新操作通常会带来随机IO），会将其放到一个insert buffer中，

　　　　　　　　　　　　　　　　　　　　 #当随后页面被读到内存中时，会将这些变化的记录merge到页中。当服务器比较空闲时，后台线程也会做merge操作

innodb_adaptive_flushing = 1　　　　　　#该值影响每秒刷新脏页的操作，开启此配置后，刷新脏页会通过判断产生重做日志的速度来判断最合适的刷新脏页的数量；

transaction-isolation = READ-COMMITTED　　#数据库事务隔离级别 ，读取提交内容

innodb_flush_method = O_DIRECT　　　　　　#innodb_flush_method这个参数控制着innodb数据文件及redo log的打开、刷写模式
　　　　　　　　　　　　　　　　　　　　　　　　#InnoDB使用O_DIRECT模式打开数据文件，用fsync()函数去更新日志和数据文件。

#innodb_use_sys_malloc = 1　　　　　　　　#默认设置值为1.设置为0：表示Innodb使用自带的内存分配程序；设置为1：表示InnoDB使用操作系统的内存分配程序。

 

[mysqldump]
quick　　　　　　　　　　　　　　　　　#它强制 mysqldump 从服务器查询取得记录直接输出而不是取得所有记录后将它们缓存到内存中

max_allowed_packet = 512M   　　　　    　　#限制server接受的数据包大小;指代mysql服务器端和客户端在一次传送数据包的过程当中数据包的大小
net_buffer_length = 16384   　　　　    　　#TCP/IP和套接字通信缓冲区大小,创建长度达net_buffer_length的行

[mysql]
auto-rehash　　　　　　　　　　　　　　#auto-rehash是自动补全的意思


[isamchk]   　　　　　　　　　　　　　　  #isamchk数据检测恢复工具
key_buffer = 256M
sort_buffer_size = 256M
read_buffer = 2M
write_buffer = 2M

 

[myisamchk]　　　　　　　　　　　　　　#使用myisamchk实用程序来获得有关你的数据库桌表的信息、检查和修复他们或优化他们
key_buffer = 256M
sort_buffer_size = 256M
read_buffer = 2M
write_buffer = 2M


[mysqlhotcopy]
interactive-timeout #mysqlhotcopy使用lock tables、flush tables和cp或scp来快速备份数据库.它是备份数据库或单个表最快的途径,完全属于物理备份,但只能用于备份MyISAM存储引擎和运行在数据库目录所在的机器上.

　　　　　　　　　　#与mysqldump备份不同,mysqldump属于逻辑备份,备份时是执行的sql语句.使用mysqlhotcopy命令前需要要安装相应的软件依赖包.
```

---
# <div align=center>my.cnf的补充知识</div>
---

## 握手

## mysqld和mysqld_safe

## Socket和TCP/IP
&emsp;&emsp;在unix/linux系统上，MySQL的登录方式有两种，分别是socket和tcp/ip。
&emsp;&emsp;当连接不指定参数时默认使用socket连接登录MySQL服务（实际上是缺省了-S socketPath），比如下面这样子；
```
[root@mysql ~]# mysql
Welcome to the MySQL monitor.  Commands end with ; or \g.
......
```
&emsp;&emsp;如果配置文件my.cnf的[client]中指定了socket配置，那么会按照指定的路径去寻找socket套接字，若是没有指定socket文件路径时，mysql默认会去寻找/tmp/mysql.sock，所以这里必须要保证在MySQL服务启动的时候，生成的socket文件必须和[client]中配置的一致，否则登录时就会报错。
```
[root@mysql ~]# mysql
ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)
```
&emsp;&emsp;那什么时候用tcp/ip连接呢？在使用mysql命令登录的时候，若指定了-h参数，则会使用tcp/ip的方式连接，如果此时没有指定端口的话，默认会使用3306端口：
```
[root@mysql ~]# mysql -h192.168.1.211
Welcome to the MySQL monitor.  Commands end with ; or \g.
......
```

## max_user_connections VS max_connections
https://www.jianshu.com/p/0996057d9593
https://www.cnblogs.com/arcer/p/5559252.html
https://www.cnblogs.com/musings/p/5930358.html

## max_connect_errors
&emsp;&emsp;错误信息形如：ERROR 1129 (00000): Host 'xxx' is blocked because of many connection errors. Unblock with 'mysqladmin flush-hosts'
https://www.cnblogs.com/kerrycode/p/8405862.html

## 几个timeout
https://blog.csdn.net/u010027484/article/details/58585589

## back_log
https://www.cnblogs.com/mydriverc/p/8296814.html

## max_allowed_packet
https://www.jianshu.com/p/629685b97030

## query_cache_xxx

查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100%
如果查询缓存碎片率超过 20%，可以用 FLUSH QUERY CACHE 整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。
查询缓存利用率 = (query_cache_size – Qcache_free_memory) / query_cache_size *100%
查询缓存利用率在 25%以下的话说明 query_cache_size 设置的过大，可适当减小;查询缓存利用率在 80%以上而且 Qcache_lowmem_prunes > 50 的话说明 query_cache_size 可能有点小，要不就是碎片太多。
查询缓存命中率 = (Qcache_hits – Qcache_inserts) / Qcache_hits * 100%
query_cache_min_res_unit = 2K 

可以通过在 MySQL 控制台执行以下命令观察：
代码:
> SHOW VARIABLES LIKE '%query_cache%';
> SHOW STATUS LIKE 'Qcache%';如果 Qcache_lowmem_prunes 的值非常大，则表明经常出现缓冲不够的情况；
如果 Qcache_hits 的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓冲； Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。
memlock # 如果你的系统支持 memlock() 函数,你也许希望打开此选项用以让运行中的 mysql 在在内存高度
紧张的时候,数据在内存中保持锁定并且防止可能被 swapping out,此选项对于性能有益
query_cache_size = 64M  

## binlog_cache_size
在一个事务中 binlog 为了记录 SQL 状态所持有的 cache 大小,如果你经常使用大的,多声明的事务,你可以增加此值来获取更大的性能.所有从事务来的状态都将被缓冲在 binlog 缓冲中然后在提交后一次性写入到 binlog 中,如果事务比此值大, 会使用磁盘上的临时文件来替代.此缓冲在每个连接的事务第一次更新状态时被创建.session 级别
binlog_cache_size = 1M 