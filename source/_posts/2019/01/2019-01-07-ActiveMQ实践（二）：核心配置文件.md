---
title: ActiveMQ实践（二）：核心配置文件
categories:
  - 消息和缓存系列之ActiveMQ
tags:
  - ActiveMQ
comments: true
date: 2019-01-07 19:09:11
---
【引言】作为一个MQ，Activemq的配置项乍一看还是有些小复杂的，所以这里也专程整理了这么一篇配置说明的文章，想要把这里面的配置全部搞明白吃透了，想必还得花些工夫。
<div align=center><img src="/img/public/000012.jpg" width="500"/></div>
<!-- more -->

&emsp;&emsp;参考版本`5.15.8`

# activemq.xml
&emsp;&emsp;文件路径一般为`~\apache-activemq-5.15.8\conf`

```xml
<!-- 【Lin.C】 首节是关于License等的说明 -->
<!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<!-- START SNIPPET: example -->

<!-- 【Lin.C】 xml namespaces和xml schema instance定义 -->
<beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
  http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd">

    <!-- 【Lin.C】 PropertyPlaceholderConfigurer是Spring相关的类，具体的关于此类的说明参考后面的章节；简单理解这个配置文件也是用来实现配置注入的 -->
    <!-- Allows us to use system properties as variables in this configuration file -->
    <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="locations">
            <value>file:${activemq.conf}/credentials.properties</value>
        </property>
    </bean>

    <!-- 【Lin.C】网上找了一大圈，也没有发现关于这个配置项的解释，猜测是关于日志监控相关的，存疑【？？？】 -->
    <!-- Allows accessing the server log -->
    <bean id="logQuery" class="io.fabric8.insight.log.log4j.Log4jLogQuery"
          lazy-init="false" scope="singleton"
          init-method="start" destroy-method="stop">
    </bean>

    <!-- 【Lin.C】broker节点是activemq的核心配置节点，首先在根节点中配置了namespace、broker的名字（保证网络环境内的唯一性）、数据存储目录 -->
    <!--
        The <broker> element is used to configure the ActiveMQ broker.
    -->
    <broker xmlns="http://activemq.apache.org/schema/core" brokerName="localhost" dataDirectory="${activemq.data}">

        <!-- 【Lin.C】为慢消费者制定的消息保留策略 -->
        <destinationPolicy>
            <policyMap>
              <policyEntries>

                <!-- 【Lin.C】 1. 仅针对topic生效，且只对nondurable的consumer有效，用于控制有大量消息在通道中积压时，broker可以保留的消息量 
                             2. 针对Topic，某条消息只有所有订阅者都消费了才会被删除 -->
                <policyEntry topic=">" >
                    <!-- The constantPendingMessageLimitStrategy is used to prevent
                         slow topic consumers to block producers and affect other consumers
                         by limiting the number of messages that are retained
                         For more information, see:
                         http://activemq.apache.org/slow-consumer-handling.html
                    -->

                  <!-- 【Lin.C】 这里的pendingMessageLimitStrategy是控制消息保存的策略的，会有两种配置方式  -->
                  <!-- 【Lin.C】 1. ConstantPendingMessageLimitStrategy，保留固定数量，超过limit则会使用MessageEvictionStrategy策略清除消息
                               2. PrefetchRatePendingMessageLimitStrategy，保留prefetchSize的N倍条消息 -->
                  <pendingMessageLimitStrategy>
                      <constantPendingMessageLimitStrategy limit="1000"/>
                      <!-- <prefetchRatePendingMessageLimitStrategy multiplier="10"/> -->
                  </pendingMessageLimitStrategy>

                  <!-- 【Lin.C】 1. 这个配置项在默认的配置文件里面是没有的.
                               2. 这个配置项也是针对慢消费者的，仅针对topic生效，且只对nondurable的consumer有效 -->
                  <!-- 【Lin.C】 1. OldestMessageEvictionStrategy: 移除最旧的消息，默认策略
                               2. OldestMessageWithLowestPriorityEvictionStrategy: 移除旧消息中权重较低的消息
                               3. UniquePropertyMessageEvictionStrategy: 移除具有指定property的旧消息。
                                  property可由开发人员指定，从此属性值相同的消息列表中移除最旧的（也就是消息创建时间最早的） -->
                  <messageEvictionStrategy>
                      <OldestMessageWithLowestPriorityEvictionStrategy />  
                  </messageEvictionStrategy>  
                </policyEntry>
              </policyEntries>
            </policyMap>
        </destinationPolicy>

         <!-- 【Lin.C】 慢消费者策略：Broker根据此配置决定如何处理慢消费者。Broker会启动一个后台线程用来监测所有的慢速消费者并按策略处理。  -->
         <!-- 【Lin.C】 1. AbortSlowConsumerStrategy: 慢消费将会被关闭；但abortConnection可控制是否关闭连接
                      2. AbortSlowConsumerStrategy: 如果慢消费者最后一个ACK距离现在的时间间隔超过maxTimeSinceLastAck，则中慢速消费者。 -->
        <slowConsumerStrategy> 
            <abortSlowConsumerStrategy abortConnection="false"/> 
            <!-- <abortSlowConsumerStrategy maxTimeSinceLastAck="3000"/> --> 
        </slowConsumerStrategy> 

        <!-- 【Lin.C】 转发策略：用于控制将消息转发给消费者的方式 -->
        <!-- 【Lin.C】 1. RoundRobinDispatchPolicy: 轮询策略，消息将按顺序依次发给每个“订阅者”。“订阅者”列表默认按照订阅的先后顺序排列，在转发消息时，
                        对于匹配消息的第一个订阅者，将会被移动到“订阅者”列表的尾部，这也意味着“下一条”消息，将会较晚的转发给它。
                     2. StrictOrderDispatchPolicy: 严格有序，消息依次发送给每个订阅者，按照“订阅者”订阅的时间先后。它和RoundRobin最大的区别是，
                        没有移动“订阅者”顺序的操作。
                     3. PriorityDispatchPolicy: 基于权重对“订阅者”排序。它要求开发者首先需要对每个订阅者指定priority，默认每个consumer的权重都一样。
                     4. SimpleDispatchPolicy: 默认值，按照当前“订阅者”列表的顺序。PriorityDispatchPolicy是其子类。 -->
        <dispatchPolicy>
            <strictOrderDispatchPolicy/>
        </dispatchPolicy>

        <!-- 【Lin.C】 恢复策略：用于控制ActiveMQ服务重启如何进行数据恢复-->
        <!-- 【Lin.C】 1. FixedSizedSubscriptionRecoveryPolicy: 保存一定size的消息，broker将为此Topic开辟定额的RAM用来保存最新的消息，使用maximumSize属性指定大小（单位：Byte）。
                     2. FixedCountSubscriptionRecoveryPolicy: 保存一定条数的消息。 使用maximumSize属性指定保存的消息条数
                     3. LastImageSubscriptionRecoveryPolicy: 只保留最新的一条数据
                     4. QueryBasedSubscriptionRecoveryPolicy: 符合置顶selector的消息都将被保存，具体能够恢复多少消息，由底层存储机制决定；比如对于非持久化消息，只要内存中还
                                                        存在，则都可以恢复。
                     5. TimedSubscriptionRecoveryPolicy: 保留最近一段时间的消息。使用recoverDuration属性指定保存时间（单位毫秒）
                     6. NoSubscriptionRecoveryPolicy: 关闭“恢复机制”，默认值。 -->
        <subscriptionRecoveryPolicy>
            <!-- eg: 恢复最近半小时内的信息-->
            <timedSubscriptionRecoveryPolicy recoverDuration="1800000"/>
            <!-- <fixedSizedSubscriptionRecoveryPolicy maximumSize="1024"/>  
            <fixedCountSubscriptionRecoveryPolicy maximumSize="100"/>   -->
        </subscriptionRecoveryPolicy>

        <!--
            The managementContext is used to configure how ActiveMQ is exposed in
            JMX. By default, ActiveMQ uses the MBean server that is started by
            the JVM. For more information, see:
            http://activemq.apache.org/jmx.html
        -->
        <managementContext>
            <managementContext createConnector="true" connectorPort="11099" />
        </managementContext>

        <!--
            Configure message persistence for the broker. The default persistence
            mechanism is the KahaDB store (identified by the kahaDB tag).
            For more information, see:

            http://activemq.apache.org/persistence.html
        -->
        <persistenceAdapter>
            <kahaDB directory="${activemq.data}/kahadb"/>
        </persistenceAdapter>


          <!--
            The systemUsage controls the maximum amount of space the broker will
            use before disabling caching and/or slowing down producers. For more information, see:
            http://activemq.apache.org/producer-flow-control.html
          -->
          <systemUsage>
            <systemUsage>
                <memoryUsage>
                    <memoryUsage percentOfJvmHeap="70" />
                </memoryUsage>
                <storeUsage>
                    <storeUsage limit="100 gb"/>
                </storeUsage>
                <tempUsage>
                    <tempUsage limit="50 gb"/>
                </tempUsage>
            </systemUsage>
        </systemUsage>

        <!--
            The transport connectors expose ActiveMQ over a given protocol to
            clients and other brokers. For more information, see:

            http://activemq.apache.org/configuring-transports.html
        -->
        <transportConnectors>
            <!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB -->
            <transportConnector name="openwire" uri="tcp://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/>
            <transportConnector name="amqp" uri="amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/>
            <transportConnector name="stomp" uri="stomp://0.0.0.0:61613?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/>
            <transportConnector name="mqtt" uri="mqtt://0.0.0.0:1883?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/>
            <transportConnector name="ws" uri="ws://0.0.0.0:61614?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/>
        </transportConnectors>

        <!-- destroy the spring context on shutdown to stop jetty -->
        <shutdownHooks>
            <bean xmlns="http://www.springframework.org/schema/beans" class="org.apache.activemq.hooks.SpringContextHook" />
        </shutdownHooks>

    </broker>

    <!--
        Enable web consoles, REST and Ajax APIs and demos
        The web consoles requires by default login, you can disable this in the jetty.xml file

        Take a look at ${ACTIVEMQ_HOME}/conf/jetty.xml for more details
    -->
    <import resource="jetty.xml"/>

</beans>
<!-- END SNIPPET: example -->
```

# XML Namespace
&emsp;&emsp;XML Namespaces一般简写为xmlns，在xml文件头上基本都会见到，它是XML（eXtensible Markup Language）的命名空间。作用是赋予命名空间一个唯一的名称。下面是从Spring的beans命名空间文件中节选的部分（参考地址： http://www.springframework.org/schema/beans/spring-beans.xsd ）。
```xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<xsd:schema xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.springframework.org/schema/beans">

    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>

    <!-- Top-level <beans> tag -->
    <xsd:element name="beans">
        <xsd:annotation>
            <xsd:documentation><![CDATA[
    Container for <bean> and other elements, typically the root element in the document.
    Allows the definition of default values for all nested bean definitions. May itself
    be nested for the purpose of defining a subset of beans with certain default values or
    to be registered only when certain profile(s) are active. Any such nested <beans> element
    must be declared as the last element in the document.
            ]]></xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element ref="description" minOccurs="0"/>
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element ref="import"/>
                    <xsd:element ref="alias"/>
                    <xsd:element ref="bean"/>
                    <xsd:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:choice>
                <xsd:element ref="beans" minOccurs="0" maxOccurs="unbounded"/>
            </xsd:sequence>
            <xsd:attribute name="profile" use="optional" type="xsd:string">
                <xsd:annotation>
                    <xsd:documentation><![CDATA[...]]></xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <!-- 省略若干行...... -->
            <xsd:anyAttribute namespace="##other" processContents="lax"/>
        </xsd:complexType>
    </xsd:element>
    
    <!-- 省略若干行...... -->
    
    <!-- simple internal types -->
    <xsd:simpleType name="defaultable-boolean">
        <xsd:restriction base="xsd:NMTOKEN">
            <xsd:enumeration value="default"/>
            <xsd:enumeration value="true"/>
            <xsd:enumeration value="false"/>
        </xsd:restriction>
    </xsd:simpleType>

</xsd:schema>
```

# PropertyPlaceholderConfigurer
&emsp;&emsp;PropertyPlaceholderConfigurer这个类是一个bean工厂后置处理器的实现类，是实现了BeanFactoryPostProcessor接口的，
```
PropertyPlaceholderConfigurer
PlaceholderResolvingStringValueResolver
PropertyPlaceholderConfigurerResolver
resolvePlaceholder
resolvePlaceholder
resolveSystemProperty
processProperties
SYSTEM_PROPERTIES_MODE_NEVER
SYSTEM_PROPERTIES_MODE_FALLBACK
SYSTEM_PROPERTIES_MODE_OVERRIDE
constants
```