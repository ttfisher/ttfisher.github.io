---
title: Java高级特性系列（一）：对象序列化（更新中...）
categories: 
	- Java Language Characteristic & Extension
tags: 
	- Java
abbrlink: '94e25669'
date: 2018-05-21 17:36:55
---
【引言】简单说呢，序列化就是把对象转成字节序列，在编码时，只要对需要序列化的类型实现了Serializbale接口，就算完成了对序列化的支持，但是序列化内部的细节是如何实现的呢？
<div align=center><img src="/img/2018-05-24-09.jpg" width="500"/></div>
<!-- more -->

# 序列化和反序列化
&emsp;&emsp;Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。
&emsp;&emsp;将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。
&emsp;&emsp;整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。

# 为什么要使用序列化？
&emsp;&emsp;第一种情况是：一般情况下Java对象的声明周期都比Java虚拟机的要短，实际应用中我们希望在JVM停止运行之后能够持久化指定的对象，这时候就需要把对象进行序列化之后保存。
&emsp;&emsp;第二种情况是：需要把Java对象通过网络进行传输的时候。因为数据只能够以二进制的形式在网络中进行传输，因此当把对象通过网络发送出去之前需要先序列化成二进制数据，在接收端读到二进制数据之后反序列化成Java对象。

# 如何完成序列化？

## 序列化深克隆实例
``` java
/**
 * 通过序列化Clone对象（深克隆）
 * - 如果不需要深克隆或类内部不包含非基本数据类型属性的情况可以通过实现Cloneable接口即可完成clone
 * 
 * @param <T> 泛型
 * @param t 需要被clone的对象
 * @return 复制后的新对象
 * @throws Exception  IO异常
 */
public static <T> T clone(T t) throws Exception {
	ObjectOutputStream out = null;
	ObjectInputStream in = null;
	try {
		ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
		out = new ObjectOutputStream(byteOut);
		out.writeObject(t);
		ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());
		in = new ObjectInputStream(byteIn);
		return (T) in.readObject();
	} finally {
		IOUtils.closeQuietly(out);
		IOUtils.closeQuietly(in);
	}
}
```

# 序列化流程分析
## ObjectOutputStream

### ObjectOutputStream的构造方法源码

``` java
public ObjectOutputStream(OutputStream out) throws IOException {
	verifySubclass();
	bout = new BlockDataOutputStream(out);
	handles = new HandleTable(10, (float) 3.00);
	subs = new ReplaceTable(10, (float) 3.00);
	enableOverride = false;
	writeStreamHeader();
	bout.setBlockDataMode(true);
	if (extendedDebugInfo) {
		debugInfoStack = new DebugTraceInfoStack();
	} else {
		debugInfoStack = null;
	}
}
```

### ObjectOutputStream的构造方法源码解读

&emsp;&emsp;构造函数中首先会把bout对象绑定到底层的字节数据容器，接着会调用writeStreamHeader()方法
``` java
// bout = new BlockDataOutputStream(out);
BlockDataOutputStream(OutputStream out) {
	this.out = out;
	dout = new DataOutputStream(this);
}
	
// writeStreamHeader();
protected void writeStreamHeader() throws IOException {
	bout.writeShort(STREAM_MAGIC);
	bout.writeShort(STREAM_VERSION);
}
```

&emsp;&emsp;在writeStreamHeader()方法中首先会往底层字节容器中写入表示序列化的Magic Number以及版本号，定义如下
``` java
/**
 * Magic number that is written to the stream header.
 */
final static short STREAM_MAGIC = (short)0xaced;

/**
 * Version number that is written to the stream header.
 */
final static short STREAM_VERSION = 5;
```

&emsp;&emsp;接下来会调用writeObject()方法进行序列化，具体实现如下:
``` java
public final void writeObject(Object obj) throws IOException {
	if (enableOverride) {
		writeObjectOverride(obj);
		return;
	}
	try {
		writeObject0(obj, false);
	} catch (IOException ex) {
		if (depth == 0) {
			writeFatalException(ex);
		}
		throw ex;
	}
}
```

&emsp;&emsp;writeObject内部调用了writeObject0，具体实现如下：
``` java
private void writeObject0(Object obj, boolean unshared)
	throws IOException
{
	boolean oldMode = bout.setBlockDataMode(false);
	depth++;
	try {
		// handle previously written and non-replaceable objects
		int h;
		if ((obj = subs.lookup(obj)) == null) {
			writeNull();
			return;
		} else if (!unshared && (h = handles.lookup(obj)) != -1) {
			writeHandle(h);
			return;
		} else if (obj instanceof Class) {
			writeClass((Class) obj, unshared);
			return;
		} else if (obj instanceof ObjectStreamClass) {
			writeClassDesc((ObjectStreamClass) obj, unshared);
			return;
		}

		// check for replacement object
		Object orig = obj;
		Class<?> cl = obj.getClass();
		ObjectStreamClass desc;
		for (;;) {
			// REMIND: skip this check for strings/arrays?
			Class<?> repCl;
			desc = ObjectStreamClass.lookup(cl, true);
			if (!desc.hasWriteReplaceMethod() ||
				(obj = desc.invokeWriteReplace(obj)) == null ||
				(repCl = obj.getClass()) == cl)
			{
				break;
			}
			cl = repCl;
		}
		if (enableReplace) {
			Object rep = replaceObject(obj);
			if (rep != obj && rep != null) {
				cl = rep.getClass();
				desc = ObjectStreamClass.lookup(cl, true);
			}
			obj = rep;
		}

		// if object replaced, run through original checks a second time
		if (obj != orig) {
			subs.assign(orig, obj);
			if (obj == null) {
				writeNull();
				return;
			} else if (!unshared && (h = handles.lookup(obj)) != -1) {
				writeHandle(h);
				return;
			} else if (obj instanceof Class) {
				writeClass((Class) obj, unshared);
				return;
			} else if (obj instanceof ObjectStreamClass) {
				writeClassDesc((ObjectStreamClass) obj, unshared);
				return;
			}
		}

		// remaining cases
		if (obj instanceof String) {
			writeString((String) obj, unshared);
		} else if (cl.isArray()) {
			writeArray(obj, desc, unshared);
		} else if (obj instanceof Enum) {
			writeEnum((Enum<?>) obj, desc, unshared);
		} else if (obj instanceof Serializable) {
			writeOrdinaryObject(obj, desc, unshared);
		} else {
			if (extendedDebugInfo) {
				throw new NotSerializableException(
					cl.getName() + "\n" + debugInfoStack.toString());
			} else {
				throw new NotSerializableException(cl.getName());
			}
		}
	} finally {
		depth--;
		bout.setBlockDataMode(oldMode);
	}
}
```

### 总结
+ **重点：待序列化的类必须实现 java.io.Serializable对象**
+ **重点：待序列化的类的所有属性必须是可序列化的。如果有属性不是可序列化的，则该属性必须注明是临时的（transient）**

## ObjectInputStream