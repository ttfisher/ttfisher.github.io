---
title: 说说集合系列（三）：Map
comments: true
categories:
  - Java one by one - collection plus
tags:
  - Java语言特性
  - Java集合
abbrlink: ae6f15ea
date: 2018-08-02 15:07:00
---
【引言】说完了Collection，接下来就要说说比Collection的结构稍稍复杂一些的Map了，作为一个key-value模式的数据结构，我们日常的编码过程中用到它的几率还是很高的，那么不同的Map实现之间有哪些区别呢？且看此篇文章一一道来。
<div align=center><img src="/img/2018/2018-08-02-12.jpg" width="500"/></div>
<!-- more -->

# Map
&emsp;&emsp;Map接口中键和值一一映射. 可以通过键来获取值。这个接口本身也有许许多多不同的实现，所使用的结构和线程安全保障方面也是不完全相同的，所以接下来就针对每种类型做个简单的解读。
<img style="clear: both;display: block;margin:auto;" src="/img/2018/2018-08-03-14.jpg" width="70%">

# HashMap

## 接口/类定义
```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {
    
    /**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

    /**
     * The maximum capacity, used if a higher value is implicitly specified
     * by either of the constructors with arguments.
     * MUST be a power of two <= 1<<30.
     */
    static final int MAXIMUM_CAPACITY = 1 << 30;

    /**
     * The load factor used when none specified in constructor.
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * Basic hash bin node, used for most entries.  (See below for
     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
     */
    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
    
    /* ---------------- Public operations -------------- */

    /**
     * Constructs an empty <tt>HashMap</tt> with the specified initial
     * capacity and load factor.
     */
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }

    /**
     * Constructs an empty <tt>HashMap</tt> with the specified initial
     * capacity and the default load factor (0.75).
     */
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Constructs an empty <tt>HashMap</tt> with the default initial capacity
     * (16) and the default load factor (0.75).
     */
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }

    /**
     * Constructs a new <tt>HashMap</tt> with the same mappings as the
     * specified <tt>Map</tt>.  
     */
    public HashMap(Map<? extends K, ? extends V> m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }
}
```

## 继承关系简图
<img style="clear: both;display: block;margin:auto;" src="/img/2018/2018-08-03-15.jpg" width="50%">

## 数据结构扩容
```java
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        ......
        ++modCount;
        
        // 重点
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
    
    final Node<K,V>[] resize() {
        // 流程过于复杂，后面单独开一章详细研究此方法
    }
```

## 特性微总结
&emsp;&emsp;对HashMap的基本特性：非线程安全、初始容量是16、扩容因子是0.75、key和value值均可为null、key不可重复、value可重复；关于具体的细节，因为此数据类型比较常用，后面会单独对此进行一个细节的分析。

# LinkedHashMap

## 接口/类定义
```java
```

## 继承关系简图
<img style="clear: both;display: block;margin:auto;" src="/img/2018/2018-08-03-15.jpg" width="50%">

## 数据结构扩容
```java
```

## 特性微总结

# TreeMap

## 接口/类定义
```java
```

## 继承关系简图
<img style="clear: both;display: block;margin:auto;" src="/img/2018/2018-08-03-15.jpg" width="50%">

## 数据结构扩容
```java
```

## 特性微总结

# WeakHashMap

## 接口/类定义
```java
```

## 继承关系简图
<img style="clear: both;display: block;margin:auto;" src="/img/2018/2018-08-03-15.jpg" width="50%">

## 数据结构扩容
```java
```

## 特性微总结

# EnumMap

## 接口/类定义
```java
```

## 继承关系简图
<img style="clear: both;display: block;margin:auto;" src="/img/2018/2018-08-03-15.jpg" width="50%">

## 数据结构扩容
```java
```

## 特性微总结

# HashTable

## 接口/类定义
```java
```

## 继承关系简图
<img style="clear: both;display: block;margin:auto;" src="/img/2018/2018-08-03-15.jpg" width="50%">

## 数据结构扩容
```java
```

## 特性微总结

# ConcurrentHashMap

## 接口/类定义
```java
```

## 继承关系简图
<img style="clear: both;display: block;margin:auto;" src="/img/2018/2018-08-03-15.jpg" width="50%">

## 数据结构扩容
```java
```

## 特性微总结
