---
title: ActiveMQ扫盲系列（五）：编码之外其二
categories:
  - 消息和缓存系列之ActiveMQ
tags:
  - ActiveMQ
comments: true
abbrlink: 31f30fa6
date: 2018-08-22 15:09:11
---
【引言】本来编码之外打算一章了事的，结果发现篇幅巨大，索性还是开第二章继续吧，前一章主要讨论了ActiveMQ的存储以及一些策略，本章主要就高可用和一些架构方面的内容来探讨一下。
<div align=center><img src="https://github.com/ttfisher/images/raw/master/public/000023.jpg" width="500"/></div>
<!-- more -->

# 高可用架构
&emsp;&emsp;HA(高可用性)几乎在所有的架构中都需要有一定的保证；ActiveMQ的高可用性架构是基于Master/Slave 模型的。ActiveMQ总共提供了四种配置方案来配置HA，其中Shared Nothing Master/Slave 在5.8版本之后不再使用了，并在ActiveMQ5.9版本中引入了基于Zookeeper的Replicated LevelDB Store HA方案。

## Shared Nothing Master/Slave

### 概述
<img style="clear: both;display: block;margin:auto;" src="https://github.com/ttfisher/images/raw/master/2018/2018-11-15-01.jpg" width="30%">
&emsp;&emsp;这个架构实际是已经被废弃的架构了，将在5.8+之后版本中移除；但是它的存在必然有存在的价值，所以了解一点也无妨。顾名思义，这个架构的一大特点是没有共享，也就是Master拥有自己的一份数据，Slave也有一份自己的数据；既然曾经存在过现在又被抛弃，那么这个架构想必是有着明显的优缺点的。

### 数据局限性
&emsp;&emsp;对非持久化消息，Master并不会同步给Slave；因此，一旦Master宕机非持久化消息会丢失。
&emsp;&emsp;Master和Slave各自单独存储一份持久化消息；Slave只是单纯的作为一个备份存在，在Master不能提供服务时能有一定的抗风险能力支撑。但是由于Master只能有一个Slave（而并不是一群Slave），虽然在一定程度上有可靠性保证，但是在抗风险性上跟集群模式相比还是有很大的差距。
&emsp;&emsp;Slave只能同步它连接到Master之后的消息，在Slave连接到Master之前Producer向Master发送的消息将不会同步给Slave；虽然这可以通过配置（waitForSlave）参数，只有当Slave也启动之后，Master才开始初始化TransportConnector接受Client的请求(Producer的请求)，但是还是不够灵活。
&emsp;&emsp;如果Master或者Slave其中之一宕机，它们之间不同步的消息无法自动进行同步，此时只能手动恢复不同步的消息了。也就是说：“ActiveMQ没有提供任何有效的手段，能够让master与slave在故障恢复期间，自动进行数据同步”。

### 响应局限性
&emsp;&emsp;Master收到持久化消息时，需要先同步(sync)给Slave之后，才向Producer发送ACK确认；这个特点会导致对Producer的响应有一定的延时；但若是先响应后同步给Slave的话，又可能会出现数据不一致的问题，这也是一个矛盾点。
&emsp;&emsp;只有Master负责Client的请求，Slave不接收Client请求。Slave连接到Master，负责备份消息；简单的说Slave对外界来说是无感知的，它只负责做Master的备胎。
&emsp;&emsp;Master一旦出现故障，Slave可以有以下两种处理方式：❶自己成为Master；❷关闭自己（停止服务）；具体怎么做根据配置而定。

### Split Brain现象
&emsp;&emsp;Master 与 Slave之间可能会出现“Split Brain”现象。比如：Master本身是正常的，但是Master与Slave之间的网络出现故障，网络故障导致Slave认为Master已经宕机，因为它自己会成为Master(根据配置：shutdownOnMasterFailure)。此时，对Client而言，就会存在两个Master。

## Shared Database Master/Slave

### 概述
<img style="clear: both;display: block;margin:auto;" src="https://github.com/ttfisher/images/raw/master/2018/2018-11-15-02.jpg" width="30%">
&emsp;&emsp;事实上ActiveMQ官方是推荐“Shared storage”模式作为首选方案，并提供了多个优秀的存储策略，其中kahadb、levedbDB、JDBC Store等都可以便捷的接入。通过命名我们也能发现，这个架构中是有数据库完成数据共享的；所以相较于无共享的模式，它的优势还是很明显的。

### 不存在单Slave的问题
&emsp;&emsp;这种模式下，对Slave的个数是没有限制的，谁能够获取到排它锁，谁就是Master，这种模式可以很好的允许集群中有任意多个节点的存在（但是节点也不是越多越好，节点过多，数据同步的消耗就越大）。

### 不存在数据同步问题
&emsp;&emsp;因为存储数据在salve与master之间共享(物理共享)，所以当master失效后，slave自动接管服务，而无需手动进行数据的Copy与同步，也无需master与slave之间进行任何额外的数据交互，因为master存储数据之后，它们在任何时候对slave都是可见的。

### 不同的锁机制
&emsp;&emsp;master与slave之间，通过database的表级排他锁、共享文件的“排他锁”或者分布式排他锁(zookeeper)来决定broker的状态与角色，获取锁权限的broker作为master，如果master失效，它必将失去锁权限，那么slaves将通过锁竞争来选举新master，没有获取锁权限的broker作为slave，并等待锁的释放(间歇性尝试获取锁)。当然slaves仍然不能为Client服务， 它只为故障转移做准备。

### 依然存在的问题
&emsp;&emsp;对于非持久化消息的同步默认还是不支持的，所有发给Master的非持久化消息不会在slaves中备份，如果Master失效，即使Slave接管了服务，此前保存在Master上的非持久化消息也将会丢失。好在有额外的插件可以支持非持久化消息的同步：
```xml
<broker>    
    <plugins>    
        <!-- 将所有消息的传输模式，修改为"PERSISTENT" -->    
      <forcePersistencyModeBrokerPlugin persistenceFlag="true"/>    
    </plugins>    
</broker>  
```

### 两种细分类别
- Shared File System master/slaves：基于共享文件系统的master/slaves模式，只能是基于POSIX接口可以访问的文件系统，比如本地文件系统或者SAN分布式共享文件系统。
- JDBC Store master/slaves：这种模式下，数据存储引擎为database，activeMQ通过JDBC的方式与database交互，排他锁使用database的表级排他锁，其他原理基本上和文件系统是一致的。

&emsp;&emsp;JDBC Store相对于日志文件而言，通常认为是低效的，尽管数据的可见性较好，但是database的扩容能力非常的弱，无法良好的适应在高并发、大数据情况下（严格来说，单组M-S架构是无法支持大数据的），况且ActiveMQ的消息通常存储时间较短，频繁的写入，频繁的删除，都是性能的影响点。
&emsp;&emsp;JJDBC Store有个小小的问题，就是临时文件无法保存在database中，我们不能在`<tmpDataStore>`使用JDBC Store；所以临时文件还是只能保存在broker本地。（即非持久消息不会保存在database中，只会保存在master上）

## Replicated LevelDB Store

### 概述
<img style="clear: both;display: block;margin:auto;" src="https://github.com/ttfisher/images/raw/master/2018/2018-11-15-03.jpg" width="30%">
&emsp;&emsp;这里提到的模式，是基于复制的LevelDB Store，这是ActiveMQ全力打造的HA存储引擎，也是目前比较符合“Master-slave”架构模型的存储方案，此特性在5.9+版本中支持。“Replicated LevelDB”也同样允许有多个Slaves，而且Slaves的个数有了约束性的限制，这归结于其使用zookeeper作为Broker master选举。

### 一些特性
&emsp;&emsp;多数派规则： 当Broker启动时，它首先向zookeeper注册自己的信息(brokerName，消息日志的版本戳等)，如果此时group中没有其他broker实例，并阻塞初始化过程，等到足够多的broker加入group；当brokers的数量达到“replicas的多数派"时，开始选举，选举将会根据“消息日志的版本戳”、“权重"的大小决定，即“版本戳”越大(数据最新)、权重越高的broker优先成为master，其他broker作为slave并跟随master。当一个broker成为master时，它会向zookeer注册自己的sync地址信息；此后slaves首先根据sync地址与master建立链接，并同步消息文件(download)。当足够多的slave数据同步结束后，master将初始化transportConnector，此后Client将可以与master进行数据交互。
 &emsp;&emsp;Master-slaves集群中，所有的broker必须具有相同的brokerName，它作为group域来限定集群的成员，brokerId可以不同，它仅作为描述信息。“replicas”参数非常重要，默认为3，表示消息最多可以备份在几个broker实例上，同是只有当“replicas/2 + 1”个broker存活时(包含master)，集群才有效，才会选举master和备份消息，此值必须>=2。Client发送给Master的持久化消息(包括ACK和事务)，master首先在本地保存，然后立即同步(sync)给选定的(replicas/2)个slaves，只有当这些节点也同步成功后，此消息的交互才算结束；对于剩下的replicas个节点，master采用异步的方式(async)转发。这种设计要求，可以保证集群中消息的可靠性，只有当(replicas/2 + 1)个节点物理故障，才会有丢失消息的风险。通常replicas为3，这要求开发者需要至少部署3个broker实例。如果replicas过大，会严重影响master的吞吐能力，因为它在sync消息的过程中会消耗太多的时间。

# failover协议

## 为什么要说它？
&emsp;&emsp;在Activemq的高可用架构中，都需要用到主备的可用性检查和平滑切换，实际应用时我们都会用到下面的配置，那么自然而然我就想了解了解这个failover到底是个什么。
```
activemq:
    broker-url: failover:(tcp://192.168.1.151:61616,tcp://192.168.1.152:61616)?randomize=false
```

## 概念剖析
&emsp;&emsp;The Failover transport layers reconnect logic on top of any of the other transports. The configuration syntax allows you to specify any number of composite URIs. The Failover transport randomly chooses one of the composite URIs and attempts to establish a connection to it. If it does not succeed, or if it subsequently fails, a new connection is established choosing one of the other URIs randomly from the list.
&emsp;&emsp;上面这段定义摘自Apache的 http://activemq.apache.org/failover-transport-reference.html ；大致理解呢就是failover是凌驾在普通协议之上的一层逻辑协议，可以支持N个不同的URI每次随机取一个访问，一旦失败可以切换到其他的URI。
&emsp;&emsp;但是通过上面的定义我们又发现一个问题，在Activemq使用时，我们是默认要用Master的，而不是随机的，那怎么办呢？想必大家已经看到了url最后有这么个参数：randomize=false，基本上也能猜个八九不离十这个参数是来控制顺序调度还是随机调度的，事实上也确实是通过这个来控制的。关于failover这个协议的一些其他参数项的具体说明，可以通过前面的链接查看，这里就不一一列举了。