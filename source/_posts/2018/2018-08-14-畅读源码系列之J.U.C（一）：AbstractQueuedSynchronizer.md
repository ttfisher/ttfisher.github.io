---
title: 畅读源码系列之J.U.C（一）：AbstractQueuedSynchronizer（未完成...)
comments: true
categories:
  - Source Code Reading - J.U.C
tags:
  - 畅读源码
abbrlink: 3ebdf4b7
date: 2018-08-14 17:37:01
---
【引言】传说J.U.C中最基础最核心的一个概念就是AQS，也就是AbstractQueuedSynchronizer，那么我们就从它开始这段奇妙旅程吧！
<div align=center><img src="/img/2018-08-15-01.jpg" width="500"/></div>
<!-- more -->

# 类基本定义

## String
```java
/**
 * 【CHENG】：首先，从开篇的图和String类的源码可以看出几个相当明显的特性：
 *         - String是final的，这也就注定了它是不能被继承，final类中的所有成员方法都会被隐式地指定为final方法
 *         - 实现了Serializable：表示String是可序列化的
 *         - 实现了Comparable：表示String是可比较的
 *         - 实现了CharSequence：实际上CharSequence是一个接口，包括StringBuffer和StringBuilder也实现了CharSequence接口
 *         - CharSequence与String都能用于定义字符串，但CharSequence的值是可读可写序列，而String的值是只读序列
 */
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    ......
}
```

# 属性和构造方法

## 基本属性
```java
    /**
     * 【CHENG】：很明显，这个数组是用做基础的存储数据结构的；所以最终有可能后续的分析都需要结合数组的特性了
     */
    /** The value is used for character storage. */
    private final char value[];
    
    /**
     * 【CHENG】：hash实际就是个散列，通常我们常见的用法就是在equals时必须要用到的hashcode方法
     */
    /** Cache the hash code for the string */
    private int hash; // Default to 0
```

## 构造方法
```java
    /**
     * 【CHENG】：这个空参构造方法本身很简单，但要结合下面的另一个构造方法看就更明了了
     */
    public String() {
        // 可以理解为 new String("").value;
        this.value = "".value;
    }
    
    /**
     * 【CHENG】：这里就有了初始化参数了，实际就是根据初始化参数给value赋值，同时给hash赋值
     */
    public String(String original) {
        this.value = original.value;
        this.hash = original.hash;
    }
    
    // 【CHENG】：还有很多基于数组之类的构造方法，因为用的不多，这里就不一一列举了
```

# 其他常用方法

## charAt
```java
    /**
     * 【CHENG】：前面了解了基本的几个属性，这个方法就很好理解了
     *        - 如果下标越界了，就抛个异常
     *        - 否则，就返回value数组对应index的那个char
     */
    public char charAt(int index) {
        if ((index < 0) || (index >= value.length)) {
            throw new StringIndexOutOfBoundsException(index);
        }
        return value[index];
    }
```
